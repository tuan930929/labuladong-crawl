{
    "url": "https://labuladong.online/algo/data-structure-basic/graph-shortest-path/",
    "title": "图结构最短路径算法概览 | labuladong 的算法笔记",
    "content": "<nav class=\"vp-breadcrumb disable\"></nav> <div class=\"vp-page-title\"><h1><!---->图结构最短路径算法概览</h1><div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"作者🖊\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">原创</span><span class=\"page-word-info\" aria-label=\"字数🔠\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>约 3498 字</span><meta property=\"wordCount\" content=\"3498\"></span></div><hr></div> <h1><!---->图结构最短路径算法概览</h1> <div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"作者🖊\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">原创</span><span class=\"page-word-info\" aria-label=\"字数🔠\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>约 3498 字</span><meta property=\"wordCount\" content=\"3498\"></span></div> <span class=\"page-author-info\" aria-label=\"作者🖊\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg> <path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path> <span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span> <a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a> <span property=\"author\" content=\"labuladong\"></span> <span class=\"page-original-info\">原创</span> <span class=\"page-word-info\" aria-label=\"字数🔠\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>约 3498 字</span><meta property=\"wordCount\" content=\"3498\"></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg> <path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path> <path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path> <span>约 3498 字</span> <meta property=\"wordCount\" content=\"3498\"> <hr> <div class=\"\" vp-content><!----><div id=\"markdown-content\"><div class=\"hint-container info\"><p class=\"hint-container-title\">前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图结构的 DFS/BFS 遍历</a></li></ul></div><div class=\"hint-container important\"><p class=\"hint-container-title\">一句话总结</p><p>Dijkstra 算法和 A* 算法是 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> 的拓展，可以处理不包含负权重的单源最短路径问题。</p><p>SPFA 算法（基于队列的 Bellman-Ford 算法）是 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> 的拓展，可以处理包含负权重的单源最短路径问题。</p><p>Floyd 算法是 <a class=\"route-link\" href=\"/algo/essential-technique/dynamic-programming-framework/\">动态规划</a> 的应用，可以处理多源最短路径问题。</p></div><div class=\"markmap-wrapper\"><svg class=\"markmap-svg\" id=\"markmap-28\"></svg><div style=\"display:flex;align-items:center;justify-content:center;height:360px;\" class=\"markmap-loading\"><span style=\"--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMidYMid' viewBox='25 25 50 50'%3E%3CanimateTransform attributeName='transform' type='rotate' dur='2s' keyTimes='0;1' repeatCount='indefinite' values='0;360'%3E%3C/animateTransform%3E%3Ccircle cx='50' cy='50' r='20' fill='none' stroke='currentColor' stroke-width='4' stroke-linecap='round'%3E%3Canimate attributeName='stroke-dasharray' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='1,200;90,200;1,200'%3E%3C/animate%3E%3Canimate attributeName='stroke-dashoffset' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='0;-35px;-125px'%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)\"></span></div></div><p>初学者不要觉得图论算法有多难，因为它们都是基于简单的算法思想扩展出来的。你把基本的二叉树层序遍历玩明白，自己都能发明出来这些算法，没啥了不起的。</p><p>考虑到目前处在基础知识章节，所以本文并不会详细讲解每种算法的完整代码，具体的代码实现会安排在之后的章节。</p><p>本文的重点在这些算法的关键原理、适用场景，以及这些高级算法和基础知识的联系，帮助初学者对图结构的最短路径算法有一个整体的认识。</p><h2 id=\"最短路径问题概览\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E6%A6%82%E8%A7%88\"><span>最短路径问题概览</span></a></h2><p>最短路径问题在生活中应用广泛，比方说计算最小成本、最短路径长度、最少时间等。</p><p>在算法中，我们一般把这类问题抽象成计算 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">加权图</a> 中的最小路径权重。为了方便表述，<strong>在本文中「最短路径」和「最小路径权重和」是等价的</strong>。</p><p>最短路径问题大致可以分为「单源最短路径」和「多源最短路径」两类，下面会介绍几个经典的算法。</p><h3 id=\"单源最短路径\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>单源最短路径</span></a></h3><p>所谓单源最短路径，就是让你计算从某个起点出发，到<strong>其他所有顶点</strong>的最短路径。</p><p>比方说一幅图中有 <code>n</code> 个节点，编号为 <code>0, 1, 2, ..., n-1</code>，让你计算从 <code>2</code> 号节点到其他节点的最短路径，这就是单源最短路径问题。</p><p>单源最短路径算法最终得到的输出应该是一个一维数组 <code>distTo</code>，<code>distTo[i]</code> 表示从起点到节点 <code>i</code> 的最短路径长度。</p><p>比较有代表性的单源最短路径算法有：</p><p>1、Dijkstra 算法，其本质是 BFS 算法 + 贪心思想，效率较高，但是不能处理带有负权重的图。</p><p>2、基于队列的 Bellman-Ford 算法，其本质也是 BFS 算法，可以处理带有负权重的图，但效率比 Dijkstra 算法低。</p><h3 id=\"点对点最短路径\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E7%82%B9%E5%AF%B9%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>点对点最短路径</span></a></h3><p>很多算法题中不需要我们计算起点到所有其他节点的最短路径，仅需要计算从起点 <code>src</code> 到某一个目标节点 <code>dst</code> 的最短路径。这类问题可以称为点对点最短路径问题。</p><p><strong>一般来说，点对点最短路径问题可以视为单源最短路径问题的特例</strong>，你可以从 <code>src</code> 开始执行单源最短路径算法，当算出到达 <code>dst</code> 的最短路径时提前结束算法。</p><p>但是下面将介绍一种专门处理点对点问题的算法：<strong>A* 算法</strong>（A Star Algorithm）。</p><p>我经常讲，算法的本质是穷举，你想要提高穷举的效率，就得尽可能充分地利用信息。点对点最短路径问题（已知起点和终点）比单源最短路径问题（已知起点）多了终点信息，所以完全有可能利用这个信息来提高算法的效率。</p><p>比方说，如果我们知道终点在起点的右下方，那么我们有理由猜测：应该优先向右下方搜索，可能可以更快地到达终点。</p><p>A* 算法的关键就在这里：它能够充分利用已知信息，有方向性地进行搜索，更快地找到终点。我们称这类算法为<strong>启发式搜索算法</strong>（Heuristic Search Algorithm）。</p><p>但是请注意，这个猜测只是经验法则，并不一定总是正确。比方说右下方可能都是死路，偏偏就得经过左上角绕个大弯才能到达终点。</p><p>所以启发式算法需要合理设置启发函数（Heuristic Function），在经验法则和实际情况中找到平衡，确保在经验法则失效时，算法的效率也不会太差。</p><h3 id=\"多源最短路径\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>多源最短路径</span></a></h3><p>所谓<strong>多源最短路径</strong>，就是让你计算任意两节点之间的最短路径。</p><p>比方说一幅图中有 <code>n</code> 个节点，编号为 <code>0, 1, 2, ..., n-1</code>，让你计算所有节点之间的最短路径，这就是多源最短路径问题。</p><p>多源最短路径算法最终得到的输出应该是一个二维数组 <code>dist</code>，<code>dist[i][j]</code> 表示从节点 <code>i</code> 到节点 <code>j</code> 的最短路径长度。</p><p>最有代表性的是 Floyd 算法，其本质是动态规划算法。</p><p>理论上，我们对所有节点都调用一次单源最短路径算法，就可以得到多源最短路径的解。</p><p>但具体实现时，要根据图结构的特点来选择。有些场景用 Floyd 这种多源最短路径算法效率更高，有些场景多次调用 Dijkstra 这种单源最短路径算法效率更高。后面讲到这些算法的复杂度时，你就能理解了。</p><h3 id=\"负权重边的影响\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E8%B4%9F%E6%9D%83%E9%87%8D%E8%BE%B9%E7%9A%84%E5%BD%B1%E5%93%8D\"><span>负权重边的影响</span></a></h3><p>在计算最短路径时，需要着重注意的是这幅图是否包含<strong>负权重边</strong>；一旦包含负权重边，一定要检查是否包含<strong>负权重环</strong>。</p><p>为啥负权重边会影响最短路径算法呢？因为负权重边会让问题变得复杂。举个最简单的例子就能直观地理解了：</p><p>比方说我们现在站在起点 <code>s</code> 上，相邻节点有 <code>a</code> 和 <code>b</code>，<code>s-&gt;a</code> 权重为 3，<code>s-&gt;b</code> 权重为 4。</p><p>如果这幅图不存在负权重边，那么根据上述信息，我就已经可以确定 <code>s</code> 到 <code>a</code> 的最短路径是 <code>s-&gt;a</code>，权重和为 3。因为你从 <code>s-&gt;b</code> 这条路径走出去，绕一圈到达 <code>a</code> 的路径权重和肯定是大于 4 的，不可能比 3 还小。</p><p>但如果这幅图存在负权重边，那可就不一定了。因为可能出现负权重边呀，比方说 <code>b-&gt;a</code> 的权重为 -10，那么从 <code>s-&gt;b-&gt;a</code> 的路径权重和为 -6，比 <code>s-&gt;a</code> 的路径权重和 3 还小。</p><p>想让 Dijkstra 这类包含贪心思想的算法成立，需要一个前提：<strong>它假设随着经过的边的数量增加，路径权重和一定也会增加</strong>。但负权重边的出现打破了这一假设，导致算法失效。</p><p>如果图中存在负权重环，最短路径问题就没有意义了。比方说 <code>s</code> 到 <code>a</code> 的路径上存在负权重环，那么你可以在这个负权重环上无限转圈，使得路径权重和无限减小下去。</p><p>常见最短路径算法中，Dijkstra 算法和 A* 算法不能处理含有负权重边的图，Floyd 算法和 Bellman-Ford 算法可以处理负权重边，Bellman-Ford 算法常用来检测负权重环。</p><p>下面，我们介绍这些算法的核心原理。</p><h2 class=\"hidden-for-toc\" id=\"dijkstra-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#dijkstra-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Dijkstra 算法简介</span></a></h2><h2 class=\"hidden-for-toc\" id=\"a-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#a-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>A* 算法简介</span></a></h2><h2 class=\"hidden-for-toc\" id=\"bellman-ford-spfa-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#bellman-ford-spfa-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Bellman-Ford/SPFA 算法简介</span></a></h2><h2 class=\"hidden-for-toc\" id=\"floyd-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#floyd-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Floyd 算法简介</span></a></h2><div id=\"hidden_part\" class=\"paywall\"><div><div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div><p>loading...</p></div></div></div><!----><!----><!----></div> <div id=\"markdown-content\"><div class=\"hint-container info\"><p class=\"hint-container-title\">前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图结构的 DFS/BFS 遍历</a></li></ul></div><div class=\"hint-container important\"><p class=\"hint-container-title\">一句话总结</p><p>Dijkstra 算法和 A* 算法是 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> 的拓展，可以处理不包含负权重的单源最短路径问题。</p><p>SPFA 算法（基于队列的 Bellman-Ford 算法）是 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> 的拓展，可以处理包含负权重的单源最短路径问题。</p><p>Floyd 算法是 <a class=\"route-link\" href=\"/algo/essential-technique/dynamic-programming-framework/\">动态规划</a> 的应用，可以处理多源最短路径问题。</p></div><div class=\"markmap-wrapper\"><svg class=\"markmap-svg\" id=\"markmap-28\"></svg><div style=\"display:flex;align-items:center;justify-content:center;height:360px;\" class=\"markmap-loading\"><span style=\"--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMidYMid' viewBox='25 25 50 50'%3E%3CanimateTransform attributeName='transform' type='rotate' dur='2s' keyTimes='0;1' repeatCount='indefinite' values='0;360'%3E%3C/animateTransform%3E%3Ccircle cx='50' cy='50' r='20' fill='none' stroke='currentColor' stroke-width='4' stroke-linecap='round'%3E%3Canimate attributeName='stroke-dasharray' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='1,200;90,200;1,200'%3E%3C/animate%3E%3Canimate attributeName='stroke-dashoffset' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='0;-35px;-125px'%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)\"></span></div></div><p>初学者不要觉得图论算法有多难，因为它们都是基于简单的算法思想扩展出来的。你把基本的二叉树层序遍历玩明白，自己都能发明出来这些算法，没啥了不起的。</p><p>考虑到目前处在基础知识章节，所以本文并不会详细讲解每种算法的完整代码，具体的代码实现会安排在之后的章节。</p><p>本文的重点在这些算法的关键原理、适用场景，以及这些高级算法和基础知识的联系，帮助初学者对图结构的最短路径算法有一个整体的认识。</p><h2 id=\"最短路径问题概览\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E6%A6%82%E8%A7%88\"><span>最短路径问题概览</span></a></h2><p>最短路径问题在生活中应用广泛，比方说计算最小成本、最短路径长度、最少时间等。</p><p>在算法中，我们一般把这类问题抽象成计算 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">加权图</a> 中的最小路径权重。为了方便表述，<strong>在本文中「最短路径」和「最小路径权重和」是等价的</strong>。</p><p>最短路径问题大致可以分为「单源最短路径」和「多源最短路径」两类，下面会介绍几个经典的算法。</p><h3 id=\"单源最短路径\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>单源最短路径</span></a></h3><p>所谓单源最短路径，就是让你计算从某个起点出发，到<strong>其他所有顶点</strong>的最短路径。</p><p>比方说一幅图中有 <code>n</code> 个节点，编号为 <code>0, 1, 2, ..., n-1</code>，让你计算从 <code>2</code> 号节点到其他节点的最短路径，这就是单源最短路径问题。</p><p>单源最短路径算法最终得到的输出应该是一个一维数组 <code>distTo</code>，<code>distTo[i]</code> 表示从起点到节点 <code>i</code> 的最短路径长度。</p><p>比较有代表性的单源最短路径算法有：</p><p>1、Dijkstra 算法，其本质是 BFS 算法 + 贪心思想，效率较高，但是不能处理带有负权重的图。</p><p>2、基于队列的 Bellman-Ford 算法，其本质也是 BFS 算法，可以处理带有负权重的图，但效率比 Dijkstra 算法低。</p><h3 id=\"点对点最短路径\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E7%82%B9%E5%AF%B9%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>点对点最短路径</span></a></h3><p>很多算法题中不需要我们计算起点到所有其他节点的最短路径，仅需要计算从起点 <code>src</code> 到某一个目标节点 <code>dst</code> 的最短路径。这类问题可以称为点对点最短路径问题。</p><p><strong>一般来说，点对点最短路径问题可以视为单源最短路径问题的特例</strong>，你可以从 <code>src</code> 开始执行单源最短路径算法，当算出到达 <code>dst</code> 的最短路径时提前结束算法。</p><p>但是下面将介绍一种专门处理点对点问题的算法：<strong>A* 算法</strong>（A Star Algorithm）。</p><p>我经常讲，算法的本质是穷举，你想要提高穷举的效率，就得尽可能充分地利用信息。点对点最短路径问题（已知起点和终点）比单源最短路径问题（已知起点）多了终点信息，所以完全有可能利用这个信息来提高算法的效率。</p><p>比方说，如果我们知道终点在起点的右下方，那么我们有理由猜测：应该优先向右下方搜索，可能可以更快地到达终点。</p><p>A* 算法的关键就在这里：它能够充分利用已知信息，有方向性地进行搜索，更快地找到终点。我们称这类算法为<strong>启发式搜索算法</strong>（Heuristic Search Algorithm）。</p><p>但是请注意，这个猜测只是经验法则，并不一定总是正确。比方说右下方可能都是死路，偏偏就得经过左上角绕个大弯才能到达终点。</p><p>所以启发式算法需要合理设置启发函数（Heuristic Function），在经验法则和实际情况中找到平衡，确保在经验法则失效时，算法的效率也不会太差。</p><h3 id=\"多源最短路径\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>多源最短路径</span></a></h3><p>所谓<strong>多源最短路径</strong>，就是让你计算任意两节点之间的最短路径。</p><p>比方说一幅图中有 <code>n</code> 个节点，编号为 <code>0, 1, 2, ..., n-1</code>，让你计算所有节点之间的最短路径，这就是多源最短路径问题。</p><p>多源最短路径算法最终得到的输出应该是一个二维数组 <code>dist</code>，<code>dist[i][j]</code> 表示从节点 <code>i</code> 到节点 <code>j</code> 的最短路径长度。</p><p>最有代表性的是 Floyd 算法，其本质是动态规划算法。</p><p>理论上，我们对所有节点都调用一次单源最短路径算法，就可以得到多源最短路径的解。</p><p>但具体实现时，要根据图结构的特点来选择。有些场景用 Floyd 这种多源最短路径算法效率更高，有些场景多次调用 Dijkstra 这种单源最短路径算法效率更高。后面讲到这些算法的复杂度时，你就能理解了。</p><h3 id=\"负权重边的影响\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E8%B4%9F%E6%9D%83%E9%87%8D%E8%BE%B9%E7%9A%84%E5%BD%B1%E5%93%8D\"><span>负权重边的影响</span></a></h3><p>在计算最短路径时，需要着重注意的是这幅图是否包含<strong>负权重边</strong>；一旦包含负权重边，一定要检查是否包含<strong>负权重环</strong>。</p><p>为啥负权重边会影响最短路径算法呢？因为负权重边会让问题变得复杂。举个最简单的例子就能直观地理解了：</p><p>比方说我们现在站在起点 <code>s</code> 上，相邻节点有 <code>a</code> 和 <code>b</code>，<code>s-&gt;a</code> 权重为 3，<code>s-&gt;b</code> 权重为 4。</p><p>如果这幅图不存在负权重边，那么根据上述信息，我就已经可以确定 <code>s</code> 到 <code>a</code> 的最短路径是 <code>s-&gt;a</code>，权重和为 3。因为你从 <code>s-&gt;b</code> 这条路径走出去，绕一圈到达 <code>a</code> 的路径权重和肯定是大于 4 的，不可能比 3 还小。</p><p>但如果这幅图存在负权重边，那可就不一定了。因为可能出现负权重边呀，比方说 <code>b-&gt;a</code> 的权重为 -10，那么从 <code>s-&gt;b-&gt;a</code> 的路径权重和为 -6，比 <code>s-&gt;a</code> 的路径权重和 3 还小。</p><p>想让 Dijkstra 这类包含贪心思想的算法成立，需要一个前提：<strong>它假设随着经过的边的数量增加，路径权重和一定也会增加</strong>。但负权重边的出现打破了这一假设，导致算法失效。</p><p>如果图中存在负权重环，最短路径问题就没有意义了。比方说 <code>s</code> 到 <code>a</code> 的路径上存在负权重环，那么你可以在这个负权重环上无限转圈，使得路径权重和无限减小下去。</p><p>常见最短路径算法中，Dijkstra 算法和 A* 算法不能处理含有负权重边的图，Floyd 算法和 Bellman-Ford 算法可以处理负权重边，Bellman-Ford 算法常用来检测负权重环。</p><p>下面，我们介绍这些算法的核心原理。</p><h2 class=\"hidden-for-toc\" id=\"dijkstra-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#dijkstra-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Dijkstra 算法简介</span></a></h2><h2 class=\"hidden-for-toc\" id=\"a-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#a-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>A* 算法简介</span></a></h2><h2 class=\"hidden-for-toc\" id=\"bellman-ford-spfa-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#bellman-ford-spfa-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Bellman-Ford/SPFA 算法简介</span></a></h2><h2 class=\"hidden-for-toc\" id=\"floyd-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#floyd-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Floyd 算法简介</span></a></h2><div id=\"hidden_part\" class=\"paywall\"><div><div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div><p>loading...</p></div></div></div> <div class=\"hint-container info\"><p class=\"hint-container-title\">前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图结构的 DFS/BFS 遍历</a></li></ul></div> <p class=\"hint-container-title\">前置知识</p> <p>阅读本文前，你需要先学习：</p> <ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图结构的 DFS/BFS 遍历</a></li></ul> <li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li> <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a> <li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图结构的 DFS/BFS 遍历</a></li> <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图结构的 DFS/BFS 遍历</a> <div class=\"hint-container important\"><p class=\"hint-container-title\">一句话总结</p><p>Dijkstra 算法和 A* 算法是 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> 的拓展，可以处理不包含负权重的单源最短路径问题。</p><p>SPFA 算法（基于队列的 Bellman-Ford 算法）是 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> 的拓展，可以处理包含负权重的单源最短路径问题。</p><p>Floyd 算法是 <a class=\"route-link\" href=\"/algo/essential-technique/dynamic-programming-framework/\">动态规划</a> 的应用，可以处理多源最短路径问题。</p></div> <p class=\"hint-container-title\">一句话总结</p> <p>Dijkstra 算法和 A* 算法是 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> 的拓展，可以处理不包含负权重的单源最短路径问题。</p> <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> <p>SPFA 算法（基于队列的 Bellman-Ford 算法）是 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> 的拓展，可以处理包含负权重的单源最短路径问题。</p> <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-traverse-basic/\">图的 BFS 遍历</a> <p>Floyd 算法是 <a class=\"route-link\" href=\"/algo/essential-technique/dynamic-programming-framework/\">动态规划</a> 的应用，可以处理多源最短路径问题。</p> <a class=\"route-link\" href=\"/algo/essential-technique/dynamic-programming-framework/\">动态规划</a> <div class=\"markmap-wrapper\"><svg class=\"markmap-svg\" id=\"markmap-28\"></svg><div style=\"display:flex;align-items:center;justify-content:center;height:360px;\" class=\"markmap-loading\"><span style=\"--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMidYMid' viewBox='25 25 50 50'%3E%3CanimateTransform attributeName='transform' type='rotate' dur='2s' keyTimes='0;1' repeatCount='indefinite' values='0;360'%3E%3C/animateTransform%3E%3Ccircle cx='50' cy='50' r='20' fill='none' stroke='currentColor' stroke-width='4' stroke-linecap='round'%3E%3Canimate attributeName='stroke-dasharray' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='1,200;90,200;1,200'%3E%3C/animate%3E%3Canimate attributeName='stroke-dashoffset' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='0;-35px;-125px'%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)\"></span></div></div> <svg class=\"markmap-svg\" id=\"markmap-28\"></svg> <div style=\"display:flex;align-items:center;justify-content:center;height:360px;\" class=\"markmap-loading\"><span style=\"--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMidYMid' viewBox='25 25 50 50'%3E%3CanimateTransform attributeName='transform' type='rotate' dur='2s' keyTimes='0;1' repeatCount='indefinite' values='0;360'%3E%3C/animateTransform%3E%3Ccircle cx='50' cy='50' r='20' fill='none' stroke='currentColor' stroke-width='4' stroke-linecap='round'%3E%3Canimate attributeName='stroke-dasharray' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='1,200;90,200;1,200'%3E%3C/animate%3E%3Canimate attributeName='stroke-dashoffset' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='0;-35px;-125px'%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)\"></span></div> <span style=\"--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMidYMid' viewBox='25 25 50 50'%3E%3CanimateTransform attributeName='transform' type='rotate' dur='2s' keyTimes='0;1' repeatCount='indefinite' values='0;360'%3E%3C/animateTransform%3E%3Ccircle cx='50' cy='50' r='20' fill='none' stroke='currentColor' stroke-width='4' stroke-linecap='round'%3E%3Canimate attributeName='stroke-dasharray' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='1,200;90,200;1,200'%3E%3C/animate%3E%3Canimate attributeName='stroke-dashoffset' dur='1.5s' keyTimes='0;0.5;1' repeatCount='indefinite' values='0;-35px;-125px'%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)\"></span> <p>初学者不要觉得图论算法有多难，因为它们都是基于简单的算法思想扩展出来的。你把基本的二叉树层序遍历玩明白，自己都能发明出来这些算法，没啥了不起的。</p> <p>考虑到目前处在基础知识章节，所以本文并不会详细讲解每种算法的完整代码，具体的代码实现会安排在之后的章节。</p> <p>本文的重点在这些算法的关键原理、适用场景，以及这些高级算法和基础知识的联系，帮助初学者对图结构的最短路径算法有一个整体的认识。</p> <h2 id=\"最短路径问题概览\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E6%A6%82%E8%A7%88\"><span>最短路径问题概览</span></a></h2> <a class=\"header-anchor\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E6%A6%82%E8%A7%88\"><span>最短路径问题概览</span></a> <span>最短路径问题概览</span> <p>最短路径问题在生活中应用广泛，比方说计算最小成本、最短路径长度、最少时间等。</p> <p>在算法中，我们一般把这类问题抽象成计算 <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">加权图</a> 中的最小路径权重。为了方便表述，<strong>在本文中「最短路径」和「最小路径权重和」是等价的</strong>。</p> <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">加权图</a> <strong>在本文中「最短路径」和「最小路径权重和」是等价的</strong> <p>最短路径问题大致可以分为「单源最短路径」和「多源最短路径」两类，下面会介绍几个经典的算法。</p> <h3 id=\"单源最短路径\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>单源最短路径</span></a></h3> <a class=\"header-anchor\" href=\"#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>单源最短路径</span></a> <span>单源最短路径</span> <p>所谓单源最短路径，就是让你计算从某个起点出发，到<strong>其他所有顶点</strong>的最短路径。</p> <strong>其他所有顶点</strong> <p>比方说一幅图中有 <code>n</code> 个节点，编号为 <code>0, 1, 2, ..., n-1</code>，让你计算从 <code>2</code> 号节点到其他节点的最短路径，这就是单源最短路径问题。</p> <code>n</code> <code>0, 1, 2, ..., n-1</code> <code>2</code> <p>单源最短路径算法最终得到的输出应该是一个一维数组 <code>distTo</code>，<code>distTo[i]</code> 表示从起点到节点 <code>i</code> 的最短路径长度。</p> <code>distTo</code> <code>distTo[i]</code> <code>i</code> <p>比较有代表性的单源最短路径算法有：</p> <p>1、Dijkstra 算法，其本质是 BFS 算法 + 贪心思想，效率较高，但是不能处理带有负权重的图。</p> <p>2、基于队列的 Bellman-Ford 算法，其本质也是 BFS 算法，可以处理带有负权重的图，但效率比 Dijkstra 算法低。</p> <h3 id=\"点对点最短路径\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E7%82%B9%E5%AF%B9%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>点对点最短路径</span></a></h3> <a class=\"header-anchor\" href=\"#%E7%82%B9%E5%AF%B9%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>点对点最短路径</span></a> <span>点对点最短路径</span> <p>很多算法题中不需要我们计算起点到所有其他节点的最短路径，仅需要计算从起点 <code>src</code> 到某一个目标节点 <code>dst</code> 的最短路径。这类问题可以称为点对点最短路径问题。</p> <code>src</code> <code>dst</code> <p><strong>一般来说，点对点最短路径问题可以视为单源最短路径问题的特例</strong>，你可以从 <code>src</code> 开始执行单源最短路径算法，当算出到达 <code>dst</code> 的最短路径时提前结束算法。</p> <strong>一般来说，点对点最短路径问题可以视为单源最短路径问题的特例</strong> <code>src</code> <code>dst</code> <p>但是下面将介绍一种专门处理点对点问题的算法：<strong>A* 算法</strong>（A Star Algorithm）。</p> <strong>A* 算法</strong> <p>我经常讲，算法的本质是穷举，你想要提高穷举的效率，就得尽可能充分地利用信息。点对点最短路径问题（已知起点和终点）比单源最短路径问题（已知起点）多了终点信息，所以完全有可能利用这个信息来提高算法的效率。</p> <p>比方说，如果我们知道终点在起点的右下方，那么我们有理由猜测：应该优先向右下方搜索，可能可以更快地到达终点。</p> <p>A* 算法的关键就在这里：它能够充分利用已知信息，有方向性地进行搜索，更快地找到终点。我们称这类算法为<strong>启发式搜索算法</strong>（Heuristic Search Algorithm）。</p> <strong>启发式搜索算法</strong> <p>但是请注意，这个猜测只是经验法则，并不一定总是正确。比方说右下方可能都是死路，偏偏就得经过左上角绕个大弯才能到达终点。</p> <p>所以启发式算法需要合理设置启发函数（Heuristic Function），在经验法则和实际情况中找到平衡，确保在经验法则失效时，算法的效率也不会太差。</p> <h3 id=\"多源最短路径\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>多源最短路径</span></a></h3> <a class=\"header-anchor\" href=\"#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span>多源最短路径</span></a> <span>多源最短路径</span> <p>所谓<strong>多源最短路径</strong>，就是让你计算任意两节点之间的最短路径。</p> <strong>多源最短路径</strong> <p>比方说一幅图中有 <code>n</code> 个节点，编号为 <code>0, 1, 2, ..., n-1</code>，让你计算所有节点之间的最短路径，这就是多源最短路径问题。</p> <code>n</code> <code>0, 1, 2, ..., n-1</code> <p>多源最短路径算法最终得到的输出应该是一个二维数组 <code>dist</code>，<code>dist[i][j]</code> 表示从节点 <code>i</code> 到节点 <code>j</code> 的最短路径长度。</p> <code>dist</code> <code>dist[i][j]</code> <code>i</code> <code>j</code> <p>最有代表性的是 Floyd 算法，其本质是动态规划算法。</p> <p>理论上，我们对所有节点都调用一次单源最短路径算法，就可以得到多源最短路径的解。</p> <p>但具体实现时，要根据图结构的特点来选择。有些场景用 Floyd 这种多源最短路径算法效率更高，有些场景多次调用 Dijkstra 这种单源最短路径算法效率更高。后面讲到这些算法的复杂度时，你就能理解了。</p> <h3 id=\"负权重边的影响\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E8%B4%9F%E6%9D%83%E9%87%8D%E8%BE%B9%E7%9A%84%E5%BD%B1%E5%93%8D\"><span>负权重边的影响</span></a></h3> <a class=\"header-anchor\" href=\"#%E8%B4%9F%E6%9D%83%E9%87%8D%E8%BE%B9%E7%9A%84%E5%BD%B1%E5%93%8D\"><span>负权重边的影响</span></a> <span>负权重边的影响</span> <p>在计算最短路径时，需要着重注意的是这幅图是否包含<strong>负权重边</strong>；一旦包含负权重边，一定要检查是否包含<strong>负权重环</strong>。</p> <strong>负权重边</strong> <strong>负权重环</strong> <p>为啥负权重边会影响最短路径算法呢？因为负权重边会让问题变得复杂。举个最简单的例子就能直观地理解了：</p> <p>比方说我们现在站在起点 <code>s</code> 上，相邻节点有 <code>a</code> 和 <code>b</code>，<code>s-&gt;a</code> 权重为 3，<code>s-&gt;b</code> 权重为 4。</p> <code>s</code> <code>a</code> <code>b</code> <code>s-&gt;a</code> <code>s-&gt;b</code> <p>如果这幅图不存在负权重边，那么根据上述信息，我就已经可以确定 <code>s</code> 到 <code>a</code> 的最短路径是 <code>s-&gt;a</code>，权重和为 3。因为你从 <code>s-&gt;b</code> 这条路径走出去，绕一圈到达 <code>a</code> 的路径权重和肯定是大于 4 的，不可能比 3 还小。</p> <code>s</code> <code>a</code> <code>s-&gt;a</code> <code>s-&gt;b</code> <code>a</code> <p>但如果这幅图存在负权重边，那可就不一定了。因为可能出现负权重边呀，比方说 <code>b-&gt;a</code> 的权重为 -10，那么从 <code>s-&gt;b-&gt;a</code> 的路径权重和为 -6，比 <code>s-&gt;a</code> 的路径权重和 3 还小。</p> <code>b-&gt;a</code> <code>s-&gt;b-&gt;a</code> <code>s-&gt;a</code> <p>想让 Dijkstra 这类包含贪心思想的算法成立，需要一个前提：<strong>它假设随着经过的边的数量增加，路径权重和一定也会增加</strong>。但负权重边的出现打破了这一假设，导致算法失效。</p> <strong>它假设随着经过的边的数量增加，路径权重和一定也会增加</strong> <p>如果图中存在负权重环，最短路径问题就没有意义了。比方说 <code>s</code> 到 <code>a</code> 的路径上存在负权重环，那么你可以在这个负权重环上无限转圈，使得路径权重和无限减小下去。</p> <code>s</code> <code>a</code> <p>常见最短路径算法中，Dijkstra 算法和 A* 算法不能处理含有负权重边的图，Floyd 算法和 Bellman-Ford 算法可以处理负权重边，Bellman-Ford 算法常用来检测负权重环。</p> <p>下面，我们介绍这些算法的核心原理。</p> <h2 class=\"hidden-for-toc\" id=\"dijkstra-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#dijkstra-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Dijkstra 算法简介</span></a></h2> <a class=\"header-anchor\" href=\"#dijkstra-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Dijkstra 算法简介</span></a> <span>Dijkstra 算法简介</span> <h2 class=\"hidden-for-toc\" id=\"a-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#a-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>A* 算法简介</span></a></h2> <a class=\"header-anchor\" href=\"#a-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>A* 算法简介</span></a> <span>A* 算法简介</span> <h2 class=\"hidden-for-toc\" id=\"bellman-ford-spfa-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#bellman-ford-spfa-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Bellman-Ford/SPFA 算法简介</span></a></h2> <a class=\"header-anchor\" href=\"#bellman-ford-spfa-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Bellman-Ford/SPFA 算法简介</span></a> <span>Bellman-Ford/SPFA 算法简介</span> <h2 class=\"hidden-for-toc\" id=\"floyd-算法简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#floyd-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Floyd 算法简介</span></a></h2> <a class=\"header-anchor\" href=\"#floyd-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B\"><span>Floyd 算法简介</span></a> <span>Floyd 算法简介</span> <div id=\"hidden_part\" class=\"paywall\"><div><div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div><p>loading...</p></div></div> <div><div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div><p>loading...</p></div> <div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div> <span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span> <i class=\"ant-spin-dot-item\"></i> <i class=\"ant-spin-dot-item\"></i> <i class=\"ant-spin-dot-item\"></i> <i class=\"ant-spin-dot-item\"></i> <p>loading...</p> <footer class=\"vp-page-meta\"><!----><div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">最近更新：</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time></div><!----></div></footer> <div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">最近更新：</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time></div><!----></div> <div class=\"update-time\"><span class=\"vp-meta-label\">最近更新：</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time></div> <span class=\"vp-meta-label\">最近更新：</span> <time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time> <nav class=\"vp-page-nav\"><a class=\"route-link auto-link prev\" href=\"/algo/data-structure-basic/eulerian-graph/\" aria-label=\"欧拉图和一笔画游戏\"><div class=\"hint\"><span class=\"arrow start\"></span>上一页</div><div class=\"link\"><!---->欧拉图和一笔画游戏</div></a><a class=\"route-link auto-link next\" href=\"/algo/data-structure-basic/graph-minimum-spanning-tree/\" aria-label=\"最小生成树算法概览\"><div class=\"hint\">下一页<span class=\"arrow end\"></span></div><div class=\"link\">最小生成树算法概览<!----></div></a></nav> <a class=\"route-link auto-link prev\" href=\"/algo/data-structure-basic/eulerian-graph/\" aria-label=\"欧拉图和一笔画游戏\"><div class=\"hint\"><span class=\"arrow start\"></span>上一页</div><div class=\"link\"><!---->欧拉图和一笔画游戏</div></a> <div class=\"hint\"><span class=\"arrow start\"></span>上一页</div> <span class=\"arrow start\"></span> <div class=\"link\"><!---->欧拉图和一笔画游戏</div> <a class=\"route-link auto-link next\" href=\"/algo/data-structure-basic/graph-minimum-spanning-tree/\" aria-label=\"最小生成树算法概览\"><div class=\"hint\">下一页<span class=\"arrow end\"></span></div><div class=\"link\">最小生成树算法概览<!----></div></a> <div class=\"hint\">下一页<span class=\"arrow end\"></span></div> <span class=\"arrow end\"></span> <div class=\"link\">最小生成树算法概览<!----></div> <div style=\"justify-content:center;display:flex;\" data-v-95bd7423><div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div></div> <div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div> <div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div> <div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div>"
}