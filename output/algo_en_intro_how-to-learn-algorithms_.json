{
    "url": "https://labuladong.online/algo/en/intro/how-to-learn-algorithms/",
    "title": "How to Learn Algorithms Efficiently | Labuladong Algo Notes",
    "content": "<nav class=\"vp-breadcrumb disable\"></nav> <div class=\"vp-page-title\"><h1><!---->How to Learn Algorithms Efficiently</h1><div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"AuthorðŸ–Š\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">Original</span><span class=\"page-word-info\" aria-label=\"WordsðŸ” \" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>About 2175 words</span><meta property=\"wordCount\" content=\"2175\"></span></div><hr></div> <h1><!---->How to Learn Algorithms Efficiently</h1> <div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"AuthorðŸ–Š\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">Original</span><span class=\"page-word-info\" aria-label=\"WordsðŸ” \" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>About 2175 words</span><meta property=\"wordCount\" content=\"2175\"></span></div> <span class=\"page-author-info\" aria-label=\"AuthorðŸ–Š\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg> <path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path> <span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span> <a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a> <span property=\"author\" content=\"labuladong\"></span> <span class=\"page-original-info\">Original</span> <span class=\"page-word-info\" aria-label=\"WordsðŸ” \" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>About 2175 words</span><meta property=\"wordCount\" content=\"2175\"></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg> <path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path> <path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path> <span>About 2175 words</span> <meta property=\"wordCount\" content=\"2175\"> <hr> <div class=\"\" vp-content><!----><div id=\"markdown-content\"><p>For job seekers in technical positions, whether in campus recruitment or social recruitment, and whether in written tests or interviews, assessing algorithms has almost become standard.</p><p>Campus recruitment candidates should pay special attention to algorithms as they are more important in such recruitment. Since you haven't worked yet, there isn't much practical project experience to discuss. Asking about standard knowledge has standard answers, and with the rise of tools like chatGPT, the value of memorizing such knowledge has decreased.</p><p>Algorithms remain the only variable with significant examination potential, making them ideal for screening campus recruits in better companies.</p><p>I recommend campus recruits start preparing early. With ample time, they can go through all the content on this site to systematically master data structures and algorithms, thereby avoiding many future job-switching hassles.</p><p>For social recruitment, work experience is undoubtedly the most crucial aspect. Good companies also test algorithms, but generally only up to a medium difficulty level, not particularly hard.</p><p>Therefore, the site provides a <a class=\"route-link\" href=\"/algo/en/intro/quick-learning-plan/\">Quick Mastery Guide</a>, specifically targeting algorithm tests to help time-constrained readers address urgent needs.</p><p>Here, I do not discuss the practical significance of algorithms in work but instead focus on scientific analysis of algorithm problem-solving and provide efficient solutions for different readers, helping everyone improve their algorithm skills. Algorithms will no longer be a stumbling block in job hunting.</p><h2 id=\"how-algorithms-are-assessed-in-job-interviews\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#how-algorithms-are-assessed-in-job-interviews\"><span>How Algorithms Are Assessed in Job Interviews</span></a></h2><p>In the context of applying for technical positions, the term \"algorithm\" generally encompasses two major components: data structures and algorithms, each of which is assessed differently.</p><p><strong>Data Structures</strong> are relatively straightforward and are typically examined during interviews. For instance, an interviewer might ask you about the principles of a hash table, why its operations such as insertion, deletion, and lookup are efficient at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, along with a series of follow-up questions. These questions are similar to rote questions, and as long as you have studied and understood them thoroughly, they are usually easy to answer.</p><p>The introductory sections of our site cover the principles and implementations of all common data structures. If time permits, you can try implementing them yourself to deepen your understanding. However, if time is limited, thoroughly understanding the principles is sufficient, and you generally won't need to manually implement data structures.</p><p><strong>Algorithms</strong> are often the more challenging part, commonly referred to as \"hand-tearing algorithm problems,\" where you are given a problem and must write a solution that passes the evaluation system.</p><p>Hand-tearing algorithm problems are guaranteed to appear in written tests, as they are a strict requirement; failing to solve them means you won't even have a chance for an interview. In most interviews, the interviewer may also ask you to solve algorithm problems on the spot. However, this is relatively easier because you can always discuss with the interviewer if you encounter difficulties.</p><p>Apart from the introductory sections on data structures, all other content on our site focuses on techniques for solving algorithm problems. It is crucial to practice solving problems yourself to truly master these algorithmic skills.</p><h2 id=\"key-points-in-practicing-algorithm-problems\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#key-points-in-practicing-algorithm-problems\"><span>Key Points in Practicing Algorithm Problems</span></a></h2><p>The key to practicing algorithm problems lies in building your own problem-solving methodology, often referred to as \"framework thinking\" on this site.</p><p>Specific problems have little value, and fleeting techniques are also not valuable. <strong>What truly holds value is a systematic, consistently reproducible problem-solving methodology.</strong></p><p>This site essentially presents a summarized thinking framework, rather than a mere collection of problem solutions. Learning this methodology justifies the time and money you invest.</p><p>When encountering new problems, this methodology can provide you with entry points, allowing you to gradually optimize and ultimately write solution code.</p><p>Algorithms are like math exams; rote memorization is ineffective. The root cause of having no ideas when faced with new problems is the lack of a personal methodology.</p><h2 id=\"why-this-site-can-help-you-learn-quickly\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#why-this-site-can-help-you-learn-quickly\"><span>Why This Site Can Help You Learn Quickly</span></a></h2><p>In high school, you might have seen students who took meticulous notes yet still struggled with exams, and those who seemed to sleep through classes but excelled. The secret of those who succeed is not in having perfectly organized notes but in possessing a strong \"ability to abstract.\"</p><p>Take programming as an example. A parent class can produce several subclasses, and a subclass can have countless instances.</p><p>If you get lost in the details of each instance, you'll be overwhelmed. Even if you memorize a thousand instances, there will be ten thousand more waiting for you. However, if you can step back from the details and see the parent class through the instances, ten thousand instances appear as just one to you. This is the power of abstraction.</p><p>In the introductory section of <a class=\"route-link\" href=\"/algo/en/essential-technique/algorithm-summary/\">Framework Thinking for Learning Data Structures and Algorithms</a>, I mentioned two key points:</p><p><strong>There are essentially only two types of data structures: arrays and linked lists.</strong> Everything else is a derivative of these two.</p><p><strong>Algorithms are essentially brute-force.</strong> The fancy algorithm names are just terms; what they do is essentially brute-force.</p><p>With these two points as guiding principles, data structures and algorithms are not as difficult as they seem. You might have found them challenging before because you didn't approach them through these perspectives.</p><p>Will having these two points make you invincible? Not quite. The next step is to concretize these concepts.</p><p>For instance, the brute-force method varies with different problems. You need to summarize and organize these scenarios by turning the repetitive parts into <strong>processes and frameworks</strong>. These frameworks become your problem-solving methodologies.</p><p>The core framework sections of this site summarize several frameworks for common algorithm problems.</p><p>Are frameworks alone enough to make you invincible? Still not quite. The next step is to <strong>internalize</strong> these frameworks through continuous practice so you can use them instinctively.</p><p>The \"Intensive Practice\" sections in this site's directory serve this purpose by providing extensive practice on the same set of frameworks, helping you develop muscle memory and truly own your problem-solving methodologies.</p><p>In summary, this is the scientific approach to problem-solving that I have developed. All content on this site revolves around this process.</p><h2 id=\"common-pitfalls-in-learning-algorithms\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#common-pitfalls-in-learning-algorithms\"><span>Common Pitfalls in Learning Algorithms</span></a></h2><h3 id=\"pitfall-one-misguidance-and-wasted-time\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-one-misguidance-and-wasted-time\"><span>Pitfall One: Misguidance and Wasted Time</span></a></h3><p>Beginners are especially prone to being misled, thinking that algorithms are very advanced and require a strong mathematical foundation, or that one must finish reading \"Introduction to Algorithms\" to truly get started. This creates an inherent fear of algorithms.</p><p>I have firsthand experience with this issue. When I first started learning algorithms, I searched through various materials and forums. I recall many so-called experts would advise reading \"Introduction to Algorithms\" and then recommend a bunch of English courses, insisting that the English versions are essential because the translations are not good.</p><p>It's like asking someone how to lose weight, and they tell you to do 100 push-ups and 200 pull-ups every day, claiming it works because that's how they did it!</p><p>Honestly, if I could manage those, why would I even ask? But if you think about it, what's the mindset behind such advice? They don't really care about your needs; they just want to show off: \"Look what I've done, isn't it impressive? You can't do it, can you?\"</p><p>Many professional algorithm books are indeed valuable, with substantial content, but their target audience differs. Most people are just looking for a tech job, and reading those books is not cost-effective.</p><p><strong>What's more cost-effective? Directly practicing problems. The direction must be clear: practicing problems is the main path, and everything else is supplementary.</strong> If you dabble in a bit of this and a bit of that, you might feel knowledgeable, but end up realizing none of it helps during a test. Then who can you blame?</p><h3 id=\"pitfall-two-greed-for-quantity-and-tricks\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-two-greed-for-quantity-and-tricks\"><span>Pitfall Two: Greed for Quantity and Tricks</span></a></h3><p>What is \"greed for quantity\"? Some readers may fall into the trap of pursuing volume. For example, some training institutions boast about having hundreds of gigabytes of materials, comprehensive in content.</p><p>In my opinion, having a large amount of material is not an advantage; rather, it's a disadvantage. Let's be honest, even if these hundreds of gigabytes of materials are really good, would you spend the time and patience to go through them, or just let them gather dust in your bookmarks?</p><p>Especially for algorithms, which are practical, just reading is not enough. If you don't practice, it remains theoretical.</p><p>What is \"greed for tricks\"? Everyone is likely to be attracted by the brilliant solutions from experts in the comment sections of platforms like LeetCode, <strong>but I want to say, before developing your own framework thinking, there's no need to pursue multiple solutions for one problem</strong>.</p><p>Pursuing multiple solutions is definitely good, but if you haven't mastered your own problem-solving methodology, it's better to practice the framework thinking on this site first.</p><p>As you learn more, you'll understand that simplicity is key. Algorithms are essentially brute-force. All content on this site revolves around these two words. In most cases, writing code according to the framework, building solutions step by step, results in the optimal solution, which is as efficient as the fancy algorithms. Why not embrace this consistent approach?</p><h3 id=\"pitfall-three-lack-of-strategy-in-problem-solving\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-three-lack-of-strategy-in-problem-solving\"><span>Pitfall Three: Lack of Strategy in Problem Solving</span></a></h3><p>Once you've determined that the main approach is practicing problems, the next pitfall is doing so without a strategyâ€”randomly tackling problems without focus. With thousands of questions on LeetCode, are you planning to solve and memorize all of them?</p><p>I don't deny that hard work can lead to breakthroughs. For example, if you manage to solve a thousand problems, you'll definitely gain some insights. However, the issue is that I have a clever method that can make one question worth ten. Would you like to learn it? Of course you would. It's quite simple: don't focus on quantity when practicing problems, but rather on summarizing and abstracting them. The ultimate goal is to develop a framework of thinking.</p><p>In essence, most algorithm problems are variations of the same themes. Once you understand the core principles, you can apply them to different scenarios with ease.</p><p><strong>Why do I emphasize this framework thinking? Because it fundamentally solves the problem of not knowing where to start with new questions.</strong></p><p>For example, if you've mastered this framework thinking, any question can be approached with a structured thought process:</p><p>What is this problem asking us to do? Ah, it's about manipulating strings. A string is essentially an array, so this problem likely involves array-related algorithm techniques.</p><p>What are the algorithm techniques for arrays? You should already have them in mind: <a class=\"route-link\" href=\"/algo/en/essential-technique/binary-search-framework/\">Binary Search</a>, <a class=\"route-link\" href=\"/algo/en/essential-technique/array-two-pointers-summary/\">Fast and Slow Pointers</a>, <a class=\"route-link\" href=\"/algo/en/essential-technique/array-two-pointers-summary/\">Left and Right Pointers</a>, <a class=\"route-link\" href=\"/algo/en/essential-technique/sliding-window-framework/\">Sliding Window</a>, <a class=\"route-link\" href=\"/algo/en/data-structure/prefix-sum/\">Prefix Sum Array</a>, <a class=\"route-link\" href=\"/algo/en/data-structure/diff-array/\">Difference Array</a>, among others.</p><p>What are the scenarios where binary search is applicable? What about difference arrays? Think through each one, and if one doesn't work, try another. You'll eventually find a relatively reliable approach.</p><p>Let's say you determine that using a sliding window is suitable for the problem. An average person, when told to use a sliding window, might struggle to write even a line of code. But you're different. You know the framework for sliding windows, so you first write the framework and then fill it in with code.</p><p>How do you fill it in? It's simple. The <a class=\"route-link\" href=\"/algo/en/essential-technique/sliding-window-framework/\">core framework of sliding windows</a> has been summarized. When using a sliding window, you should ask yourself three questions. Answer these questions, and you'll have solved the problem and submitted the code successfully. Isn't that satisfying?</p><p>Enjoyable, right? Then I'll give you 100 <a class=\"route-link\" href=\"/algo/en/problem-set/sliding-window/\">sliding window exercises</a>. You'll solve them by following the same pattern, making minor adjustments. Does the algorithm still seem difficult to you now?</p><h3 id=\"pitfall-four-inconsistent-problem-solving-style\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-four-inconsistent-problem-solving-style\"><span>Pitfall Four: Inconsistent Problem-Solving Style</span></a></h3><p>If you've avoided the previous pitfalls, you can now explore issues at a more detailed level.</p><p>For example, when you look at solutions written by different people, their coding styles, such as algorithm frameworks and variable naming, may differ, which can create issues.</p><p>There is no absolute right or wrong in style, but for beginners, different coding styles can increase the cost of understanding. Moreover, beginners might unconsciously adopt others' coding styles, leading to an inconsistent problem-solving style of their own, making it difficult to form a fixed routine, and reducing stability in performance.</p><p>All algorithm frameworks and coding styles on this site maintain a consistent style, and we even explain why we use these styles. For example, <a class=\"route-link\" href=\"/algo/en/essential-technique/backtrack-vs-dfs/\">Answering Questions on Backtracking/DFS Algorithms</a> explains why the recursive function of backtracking/DFS algorithms should not have a return value.</p><p>I recommend beginners use a relatively consistent coding style and template. First, thoroughly understand and master the template, then you can write however you like, because you'll be able to write correctly in any style.</p></div><!----><!----><!----></div> <div id=\"markdown-content\"><p>For job seekers in technical positions, whether in campus recruitment or social recruitment, and whether in written tests or interviews, assessing algorithms has almost become standard.</p><p>Campus recruitment candidates should pay special attention to algorithms as they are more important in such recruitment. Since you haven't worked yet, there isn't much practical project experience to discuss. Asking about standard knowledge has standard answers, and with the rise of tools like chatGPT, the value of memorizing such knowledge has decreased.</p><p>Algorithms remain the only variable with significant examination potential, making them ideal for screening campus recruits in better companies.</p><p>I recommend campus recruits start preparing early. With ample time, they can go through all the content on this site to systematically master data structures and algorithms, thereby avoiding many future job-switching hassles.</p><p>For social recruitment, work experience is undoubtedly the most crucial aspect. Good companies also test algorithms, but generally only up to a medium difficulty level, not particularly hard.</p><p>Therefore, the site provides a <a class=\"route-link\" href=\"/algo/en/intro/quick-learning-plan/\">Quick Mastery Guide</a>, specifically targeting algorithm tests to help time-constrained readers address urgent needs.</p><p>Here, I do not discuss the practical significance of algorithms in work but instead focus on scientific analysis of algorithm problem-solving and provide efficient solutions for different readers, helping everyone improve their algorithm skills. Algorithms will no longer be a stumbling block in job hunting.</p><h2 id=\"how-algorithms-are-assessed-in-job-interviews\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#how-algorithms-are-assessed-in-job-interviews\"><span>How Algorithms Are Assessed in Job Interviews</span></a></h2><p>In the context of applying for technical positions, the term \"algorithm\" generally encompasses two major components: data structures and algorithms, each of which is assessed differently.</p><p><strong>Data Structures</strong> are relatively straightforward and are typically examined during interviews. For instance, an interviewer might ask you about the principles of a hash table, why its operations such as insertion, deletion, and lookup are efficient at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, along with a series of follow-up questions. These questions are similar to rote questions, and as long as you have studied and understood them thoroughly, they are usually easy to answer.</p><p>The introductory sections of our site cover the principles and implementations of all common data structures. If time permits, you can try implementing them yourself to deepen your understanding. However, if time is limited, thoroughly understanding the principles is sufficient, and you generally won't need to manually implement data structures.</p><p><strong>Algorithms</strong> are often the more challenging part, commonly referred to as \"hand-tearing algorithm problems,\" where you are given a problem and must write a solution that passes the evaluation system.</p><p>Hand-tearing algorithm problems are guaranteed to appear in written tests, as they are a strict requirement; failing to solve them means you won't even have a chance for an interview. In most interviews, the interviewer may also ask you to solve algorithm problems on the spot. However, this is relatively easier because you can always discuss with the interviewer if you encounter difficulties.</p><p>Apart from the introductory sections on data structures, all other content on our site focuses on techniques for solving algorithm problems. It is crucial to practice solving problems yourself to truly master these algorithmic skills.</p><h2 id=\"key-points-in-practicing-algorithm-problems\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#key-points-in-practicing-algorithm-problems\"><span>Key Points in Practicing Algorithm Problems</span></a></h2><p>The key to practicing algorithm problems lies in building your own problem-solving methodology, often referred to as \"framework thinking\" on this site.</p><p>Specific problems have little value, and fleeting techniques are also not valuable. <strong>What truly holds value is a systematic, consistently reproducible problem-solving methodology.</strong></p><p>This site essentially presents a summarized thinking framework, rather than a mere collection of problem solutions. Learning this methodology justifies the time and money you invest.</p><p>When encountering new problems, this methodology can provide you with entry points, allowing you to gradually optimize and ultimately write solution code.</p><p>Algorithms are like math exams; rote memorization is ineffective. The root cause of having no ideas when faced with new problems is the lack of a personal methodology.</p><h2 id=\"why-this-site-can-help-you-learn-quickly\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#why-this-site-can-help-you-learn-quickly\"><span>Why This Site Can Help You Learn Quickly</span></a></h2><p>In high school, you might have seen students who took meticulous notes yet still struggled with exams, and those who seemed to sleep through classes but excelled. The secret of those who succeed is not in having perfectly organized notes but in possessing a strong \"ability to abstract.\"</p><p>Take programming as an example. A parent class can produce several subclasses, and a subclass can have countless instances.</p><p>If you get lost in the details of each instance, you'll be overwhelmed. Even if you memorize a thousand instances, there will be ten thousand more waiting for you. However, if you can step back from the details and see the parent class through the instances, ten thousand instances appear as just one to you. This is the power of abstraction.</p><p>In the introductory section of <a class=\"route-link\" href=\"/algo/en/essential-technique/algorithm-summary/\">Framework Thinking for Learning Data Structures and Algorithms</a>, I mentioned two key points:</p><p><strong>There are essentially only two types of data structures: arrays and linked lists.</strong> Everything else is a derivative of these two.</p><p><strong>Algorithms are essentially brute-force.</strong> The fancy algorithm names are just terms; what they do is essentially brute-force.</p><p>With these two points as guiding principles, data structures and algorithms are not as difficult as they seem. You might have found them challenging before because you didn't approach them through these perspectives.</p><p>Will having these two points make you invincible? Not quite. The next step is to concretize these concepts.</p><p>For instance, the brute-force method varies with different problems. You need to summarize and organize these scenarios by turning the repetitive parts into <strong>processes and frameworks</strong>. These frameworks become your problem-solving methodologies.</p><p>The core framework sections of this site summarize several frameworks for common algorithm problems.</p><p>Are frameworks alone enough to make you invincible? Still not quite. The next step is to <strong>internalize</strong> these frameworks through continuous practice so you can use them instinctively.</p><p>The \"Intensive Practice\" sections in this site's directory serve this purpose by providing extensive practice on the same set of frameworks, helping you develop muscle memory and truly own your problem-solving methodologies.</p><p>In summary, this is the scientific approach to problem-solving that I have developed. All content on this site revolves around this process.</p><h2 id=\"common-pitfalls-in-learning-algorithms\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#common-pitfalls-in-learning-algorithms\"><span>Common Pitfalls in Learning Algorithms</span></a></h2><h3 id=\"pitfall-one-misguidance-and-wasted-time\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-one-misguidance-and-wasted-time\"><span>Pitfall One: Misguidance and Wasted Time</span></a></h3><p>Beginners are especially prone to being misled, thinking that algorithms are very advanced and require a strong mathematical foundation, or that one must finish reading \"Introduction to Algorithms\" to truly get started. This creates an inherent fear of algorithms.</p><p>I have firsthand experience with this issue. When I first started learning algorithms, I searched through various materials and forums. I recall many so-called experts would advise reading \"Introduction to Algorithms\" and then recommend a bunch of English courses, insisting that the English versions are essential because the translations are not good.</p><p>It's like asking someone how to lose weight, and they tell you to do 100 push-ups and 200 pull-ups every day, claiming it works because that's how they did it!</p><p>Honestly, if I could manage those, why would I even ask? But if you think about it, what's the mindset behind such advice? They don't really care about your needs; they just want to show off: \"Look what I've done, isn't it impressive? You can't do it, can you?\"</p><p>Many professional algorithm books are indeed valuable, with substantial content, but their target audience differs. Most people are just looking for a tech job, and reading those books is not cost-effective.</p><p><strong>What's more cost-effective? Directly practicing problems. The direction must be clear: practicing problems is the main path, and everything else is supplementary.</strong> If you dabble in a bit of this and a bit of that, you might feel knowledgeable, but end up realizing none of it helps during a test. Then who can you blame?</p><h3 id=\"pitfall-two-greed-for-quantity-and-tricks\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-two-greed-for-quantity-and-tricks\"><span>Pitfall Two: Greed for Quantity and Tricks</span></a></h3><p>What is \"greed for quantity\"? Some readers may fall into the trap of pursuing volume. For example, some training institutions boast about having hundreds of gigabytes of materials, comprehensive in content.</p><p>In my opinion, having a large amount of material is not an advantage; rather, it's a disadvantage. Let's be honest, even if these hundreds of gigabytes of materials are really good, would you spend the time and patience to go through them, or just let them gather dust in your bookmarks?</p><p>Especially for algorithms, which are practical, just reading is not enough. If you don't practice, it remains theoretical.</p><p>What is \"greed for tricks\"? Everyone is likely to be attracted by the brilliant solutions from experts in the comment sections of platforms like LeetCode, <strong>but I want to say, before developing your own framework thinking, there's no need to pursue multiple solutions for one problem</strong>.</p><p>Pursuing multiple solutions is definitely good, but if you haven't mastered your own problem-solving methodology, it's better to practice the framework thinking on this site first.</p><p>As you learn more, you'll understand that simplicity is key. Algorithms are essentially brute-force. All content on this site revolves around these two words. In most cases, writing code according to the framework, building solutions step by step, results in the optimal solution, which is as efficient as the fancy algorithms. Why not embrace this consistent approach?</p><h3 id=\"pitfall-three-lack-of-strategy-in-problem-solving\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-three-lack-of-strategy-in-problem-solving\"><span>Pitfall Three: Lack of Strategy in Problem Solving</span></a></h3><p>Once you've determined that the main approach is practicing problems, the next pitfall is doing so without a strategyâ€”randomly tackling problems without focus. With thousands of questions on LeetCode, are you planning to solve and memorize all of them?</p><p>I don't deny that hard work can lead to breakthroughs. For example, if you manage to solve a thousand problems, you'll definitely gain some insights. However, the issue is that I have a clever method that can make one question worth ten. Would you like to learn it? Of course you would. It's quite simple: don't focus on quantity when practicing problems, but rather on summarizing and abstracting them. The ultimate goal is to develop a framework of thinking.</p><p>In essence, most algorithm problems are variations of the same themes. Once you understand the core principles, you can apply them to different scenarios with ease.</p><p><strong>Why do I emphasize this framework thinking? Because it fundamentally solves the problem of not knowing where to start with new questions.</strong></p><p>For example, if you've mastered this framework thinking, any question can be approached with a structured thought process:</p><p>What is this problem asking us to do? Ah, it's about manipulating strings. A string is essentially an array, so this problem likely involves array-related algorithm techniques.</p><p>What are the algorithm techniques for arrays? You should already have them in mind: <a class=\"route-link\" href=\"/algo/en/essential-technique/binary-search-framework/\">Binary Search</a>, <a class=\"route-link\" href=\"/algo/en/essential-technique/array-two-pointers-summary/\">Fast and Slow Pointers</a>, <a class=\"route-link\" href=\"/algo/en/essential-technique/array-two-pointers-summary/\">Left and Right Pointers</a>, <a class=\"route-link\" href=\"/algo/en/essential-technique/sliding-window-framework/\">Sliding Window</a>, <a class=\"route-link\" href=\"/algo/en/data-structure/prefix-sum/\">Prefix Sum Array</a>, <a class=\"route-link\" href=\"/algo/en/data-structure/diff-array/\">Difference Array</a>, among others.</p><p>What are the scenarios where binary search is applicable? What about difference arrays? Think through each one, and if one doesn't work, try another. You'll eventually find a relatively reliable approach.</p><p>Let's say you determine that using a sliding window is suitable for the problem. An average person, when told to use a sliding window, might struggle to write even a line of code. But you're different. You know the framework for sliding windows, so you first write the framework and then fill it in with code.</p><p>How do you fill it in? It's simple. The <a class=\"route-link\" href=\"/algo/en/essential-technique/sliding-window-framework/\">core framework of sliding windows</a> has been summarized. When using a sliding window, you should ask yourself three questions. Answer these questions, and you'll have solved the problem and submitted the code successfully. Isn't that satisfying?</p><p>Enjoyable, right? Then I'll give you 100 <a class=\"route-link\" href=\"/algo/en/problem-set/sliding-window/\">sliding window exercises</a>. You'll solve them by following the same pattern, making minor adjustments. Does the algorithm still seem difficult to you now?</p><h3 id=\"pitfall-four-inconsistent-problem-solving-style\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-four-inconsistent-problem-solving-style\"><span>Pitfall Four: Inconsistent Problem-Solving Style</span></a></h3><p>If you've avoided the previous pitfalls, you can now explore issues at a more detailed level.</p><p>For example, when you look at solutions written by different people, their coding styles, such as algorithm frameworks and variable naming, may differ, which can create issues.</p><p>There is no absolute right or wrong in style, but for beginners, different coding styles can increase the cost of understanding. Moreover, beginners might unconsciously adopt others' coding styles, leading to an inconsistent problem-solving style of their own, making it difficult to form a fixed routine, and reducing stability in performance.</p><p>All algorithm frameworks and coding styles on this site maintain a consistent style, and we even explain why we use these styles. For example, <a class=\"route-link\" href=\"/algo/en/essential-technique/backtrack-vs-dfs/\">Answering Questions on Backtracking/DFS Algorithms</a> explains why the recursive function of backtracking/DFS algorithms should not have a return value.</p><p>I recommend beginners use a relatively consistent coding style and template. First, thoroughly understand and master the template, then you can write however you like, because you'll be able to write correctly in any style.</p></div> <p>For job seekers in technical positions, whether in campus recruitment or social recruitment, and whether in written tests or interviews, assessing algorithms has almost become standard.</p> <p>Campus recruitment candidates should pay special attention to algorithms as they are more important in such recruitment. Since you haven't worked yet, there isn't much practical project experience to discuss. Asking about standard knowledge has standard answers, and with the rise of tools like chatGPT, the value of memorizing such knowledge has decreased.</p> <p>Algorithms remain the only variable with significant examination potential, making them ideal for screening campus recruits in better companies.</p> <p>I recommend campus recruits start preparing early. With ample time, they can go through all the content on this site to systematically master data structures and algorithms, thereby avoiding many future job-switching hassles.</p> <p>For social recruitment, work experience is undoubtedly the most crucial aspect. Good companies also test algorithms, but generally only up to a medium difficulty level, not particularly hard.</p> <p>Therefore, the site provides a <a class=\"route-link\" href=\"/algo/en/intro/quick-learning-plan/\">Quick Mastery Guide</a>, specifically targeting algorithm tests to help time-constrained readers address urgent needs.</p> <a class=\"route-link\" href=\"/algo/en/intro/quick-learning-plan/\">Quick Mastery Guide</a> <p>Here, I do not discuss the practical significance of algorithms in work but instead focus on scientific analysis of algorithm problem-solving and provide efficient solutions for different readers, helping everyone improve their algorithm skills. Algorithms will no longer be a stumbling block in job hunting.</p> <h2 id=\"how-algorithms-are-assessed-in-job-interviews\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#how-algorithms-are-assessed-in-job-interviews\"><span>How Algorithms Are Assessed in Job Interviews</span></a></h2> <a class=\"header-anchor\" href=\"#how-algorithms-are-assessed-in-job-interviews\"><span>How Algorithms Are Assessed in Job Interviews</span></a> <span>How Algorithms Are Assessed in Job Interviews</span> <p>In the context of applying for technical positions, the term \"algorithm\" generally encompasses two major components: data structures and algorithms, each of which is assessed differently.</p> <p><strong>Data Structures</strong> are relatively straightforward and are typically examined during interviews. For instance, an interviewer might ask you about the principles of a hash table, why its operations such as insertion, deletion, and lookup are efficient at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, along with a series of follow-up questions. These questions are similar to rote questions, and as long as you have studied and understood them thoroughly, they are usually easy to answer.</p> <strong>Data Structures</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math> <semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics> <mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow> <mi>O</mi> <mo stretchy=\"false\">(</mo> <mn>1</mn> <mo stretchy=\"false\">)</mo> <annotation encoding=\"application/x-tex\">O(1)</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span> <span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span> <span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span> <span class=\"mopen\">(</span> <span class=\"mord\">1</span> <span class=\"mclose\">)</span> <p>The introductory sections of our site cover the principles and implementations of all common data structures. If time permits, you can try implementing them yourself to deepen your understanding. However, if time is limited, thoroughly understanding the principles is sufficient, and you generally won't need to manually implement data structures.</p> <p><strong>Algorithms</strong> are often the more challenging part, commonly referred to as \"hand-tearing algorithm problems,\" where you are given a problem and must write a solution that passes the evaluation system.</p> <strong>Algorithms</strong> <p>Hand-tearing algorithm problems are guaranteed to appear in written tests, as they are a strict requirement; failing to solve them means you won't even have a chance for an interview. In most interviews, the interviewer may also ask you to solve algorithm problems on the spot. However, this is relatively easier because you can always discuss with the interviewer if you encounter difficulties.</p> <p>Apart from the introductory sections on data structures, all other content on our site focuses on techniques for solving algorithm problems. It is crucial to practice solving problems yourself to truly master these algorithmic skills.</p> <h2 id=\"key-points-in-practicing-algorithm-problems\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#key-points-in-practicing-algorithm-problems\"><span>Key Points in Practicing Algorithm Problems</span></a></h2> <a class=\"header-anchor\" href=\"#key-points-in-practicing-algorithm-problems\"><span>Key Points in Practicing Algorithm Problems</span></a> <span>Key Points in Practicing Algorithm Problems</span> <p>The key to practicing algorithm problems lies in building your own problem-solving methodology, often referred to as \"framework thinking\" on this site.</p> <p>Specific problems have little value, and fleeting techniques are also not valuable. <strong>What truly holds value is a systematic, consistently reproducible problem-solving methodology.</strong></p> <strong>What truly holds value is a systematic, consistently reproducible problem-solving methodology.</strong> <p>This site essentially presents a summarized thinking framework, rather than a mere collection of problem solutions. Learning this methodology justifies the time and money you invest.</p> <p>When encountering new problems, this methodology can provide you with entry points, allowing you to gradually optimize and ultimately write solution code.</p> <p>Algorithms are like math exams; rote memorization is ineffective. The root cause of having no ideas when faced with new problems is the lack of a personal methodology.</p> <h2 id=\"why-this-site-can-help-you-learn-quickly\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#why-this-site-can-help-you-learn-quickly\"><span>Why This Site Can Help You Learn Quickly</span></a></h2> <a class=\"header-anchor\" href=\"#why-this-site-can-help-you-learn-quickly\"><span>Why This Site Can Help You Learn Quickly</span></a> <span>Why This Site Can Help You Learn Quickly</span> <p>In high school, you might have seen students who took meticulous notes yet still struggled with exams, and those who seemed to sleep through classes but excelled. The secret of those who succeed is not in having perfectly organized notes but in possessing a strong \"ability to abstract.\"</p> <p>Take programming as an example. A parent class can produce several subclasses, and a subclass can have countless instances.</p> <p>If you get lost in the details of each instance, you'll be overwhelmed. Even if you memorize a thousand instances, there will be ten thousand more waiting for you. However, if you can step back from the details and see the parent class through the instances, ten thousand instances appear as just one to you. This is the power of abstraction.</p> <p>In the introductory section of <a class=\"route-link\" href=\"/algo/en/essential-technique/algorithm-summary/\">Framework Thinking for Learning Data Structures and Algorithms</a>, I mentioned two key points:</p> <a class=\"route-link\" href=\"/algo/en/essential-technique/algorithm-summary/\">Framework Thinking for Learning Data Structures and Algorithms</a> <p><strong>There are essentially only two types of data structures: arrays and linked lists.</strong> Everything else is a derivative of these two.</p> <strong>There are essentially only two types of data structures: arrays and linked lists.</strong> <p><strong>Algorithms are essentially brute-force.</strong> The fancy algorithm names are just terms; what they do is essentially brute-force.</p> <strong>Algorithms are essentially brute-force.</strong> <p>With these two points as guiding principles, data structures and algorithms are not as difficult as they seem. You might have found them challenging before because you didn't approach them through these perspectives.</p> <p>Will having these two points make you invincible? Not quite. The next step is to concretize these concepts.</p> <p>For instance, the brute-force method varies with different problems. You need to summarize and organize these scenarios by turning the repetitive parts into <strong>processes and frameworks</strong>. These frameworks become your problem-solving methodologies.</p> <strong>processes and frameworks</strong> <p>The core framework sections of this site summarize several frameworks for common algorithm problems.</p> <p>Are frameworks alone enough to make you invincible? Still not quite. The next step is to <strong>internalize</strong> these frameworks through continuous practice so you can use them instinctively.</p> <strong>internalize</strong> <p>The \"Intensive Practice\" sections in this site's directory serve this purpose by providing extensive practice on the same set of frameworks, helping you develop muscle memory and truly own your problem-solving methodologies.</p> <p>In summary, this is the scientific approach to problem-solving that I have developed. All content on this site revolves around this process.</p> <h2 id=\"common-pitfalls-in-learning-algorithms\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#common-pitfalls-in-learning-algorithms\"><span>Common Pitfalls in Learning Algorithms</span></a></h2> <a class=\"header-anchor\" href=\"#common-pitfalls-in-learning-algorithms\"><span>Common Pitfalls in Learning Algorithms</span></a> <span>Common Pitfalls in Learning Algorithms</span> <h3 id=\"pitfall-one-misguidance-and-wasted-time\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-one-misguidance-and-wasted-time\"><span>Pitfall One: Misguidance and Wasted Time</span></a></h3> <a class=\"header-anchor\" href=\"#pitfall-one-misguidance-and-wasted-time\"><span>Pitfall One: Misguidance and Wasted Time</span></a> <span>Pitfall One: Misguidance and Wasted Time</span> <p>Beginners are especially prone to being misled, thinking that algorithms are very advanced and require a strong mathematical foundation, or that one must finish reading \"Introduction to Algorithms\" to truly get started. This creates an inherent fear of algorithms.</p> <p>I have firsthand experience with this issue. When I first started learning algorithms, I searched through various materials and forums. I recall many so-called experts would advise reading \"Introduction to Algorithms\" and then recommend a bunch of English courses, insisting that the English versions are essential because the translations are not good.</p> <p>It's like asking someone how to lose weight, and they tell you to do 100 push-ups and 200 pull-ups every day, claiming it works because that's how they did it!</p> <p>Honestly, if I could manage those, why would I even ask? But if you think about it, what's the mindset behind such advice? They don't really care about your needs; they just want to show off: \"Look what I've done, isn't it impressive? You can't do it, can you?\"</p> <p>Many professional algorithm books are indeed valuable, with substantial content, but their target audience differs. Most people are just looking for a tech job, and reading those books is not cost-effective.</p> <p><strong>What's more cost-effective? Directly practicing problems. The direction must be clear: practicing problems is the main path, and everything else is supplementary.</strong> If you dabble in a bit of this and a bit of that, you might feel knowledgeable, but end up realizing none of it helps during a test. Then who can you blame?</p> <strong>What's more cost-effective? Directly practicing problems. The direction must be clear: practicing problems is the main path, and everything else is supplementary.</strong> <h3 id=\"pitfall-two-greed-for-quantity-and-tricks\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-two-greed-for-quantity-and-tricks\"><span>Pitfall Two: Greed for Quantity and Tricks</span></a></h3> <a class=\"header-anchor\" href=\"#pitfall-two-greed-for-quantity-and-tricks\"><span>Pitfall Two: Greed for Quantity and Tricks</span></a> <span>Pitfall Two: Greed for Quantity and Tricks</span> <p>What is \"greed for quantity\"? Some readers may fall into the trap of pursuing volume. For example, some training institutions boast about having hundreds of gigabytes of materials, comprehensive in content.</p> <p>In my opinion, having a large amount of material is not an advantage; rather, it's a disadvantage. Let's be honest, even if these hundreds of gigabytes of materials are really good, would you spend the time and patience to go through them, or just let them gather dust in your bookmarks?</p> <p>Especially for algorithms, which are practical, just reading is not enough. If you don't practice, it remains theoretical.</p> <p>What is \"greed for tricks\"? Everyone is likely to be attracted by the brilliant solutions from experts in the comment sections of platforms like LeetCode, <strong>but I want to say, before developing your own framework thinking, there's no need to pursue multiple solutions for one problem</strong>.</p> <strong>but I want to say, before developing your own framework thinking, there's no need to pursue multiple solutions for one problem</strong> <p>Pursuing multiple solutions is definitely good, but if you haven't mastered your own problem-solving methodology, it's better to practice the framework thinking on this site first.</p> <p>As you learn more, you'll understand that simplicity is key. Algorithms are essentially brute-force. All content on this site revolves around these two words. In most cases, writing code according to the framework, building solutions step by step, results in the optimal solution, which is as efficient as the fancy algorithms. Why not embrace this consistent approach?</p> <h3 id=\"pitfall-three-lack-of-strategy-in-problem-solving\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-three-lack-of-strategy-in-problem-solving\"><span>Pitfall Three: Lack of Strategy in Problem Solving</span></a></h3> <a class=\"header-anchor\" href=\"#pitfall-three-lack-of-strategy-in-problem-solving\"><span>Pitfall Three: Lack of Strategy in Problem Solving</span></a> <span>Pitfall Three: Lack of Strategy in Problem Solving</span> <p>Once you've determined that the main approach is practicing problems, the next pitfall is doing so without a strategyâ€”randomly tackling problems without focus. With thousands of questions on LeetCode, are you planning to solve and memorize all of them?</p> <p>I don't deny that hard work can lead to breakthroughs. For example, if you manage to solve a thousand problems, you'll definitely gain some insights. However, the issue is that I have a clever method that can make one question worth ten. Would you like to learn it? Of course you would. It's quite simple: don't focus on quantity when practicing problems, but rather on summarizing and abstracting them. The ultimate goal is to develop a framework of thinking.</p> <p>In essence, most algorithm problems are variations of the same themes. Once you understand the core principles, you can apply them to different scenarios with ease.</p> <p><strong>Why do I emphasize this framework thinking? Because it fundamentally solves the problem of not knowing where to start with new questions.</strong></p> <strong>Why do I emphasize this framework thinking? Because it fundamentally solves the problem of not knowing where to start with new questions.</strong> <p>For example, if you've mastered this framework thinking, any question can be approached with a structured thought process:</p> <p>What is this problem asking us to do? Ah, it's about manipulating strings. A string is essentially an array, so this problem likely involves array-related algorithm techniques.</p> <p>What are the algorithm techniques for arrays? You should already have them in mind: <a class=\"route-link\" href=\"/algo/en/essential-technique/binary-search-framework/\">Binary Search</a>, <a class=\"route-link\" href=\"/algo/en/essential-technique/array-two-pointers-summary/\">Fast and Slow Pointers</a>, <a class=\"route-link\" href=\"/algo/en/essential-technique/array-two-pointers-summary/\">Left and Right Pointers</a>, <a class=\"route-link\" href=\"/algo/en/essential-technique/sliding-window-framework/\">Sliding Window</a>, <a class=\"route-link\" href=\"/algo/en/data-structure/prefix-sum/\">Prefix Sum Array</a>, <a class=\"route-link\" href=\"/algo/en/data-structure/diff-array/\">Difference Array</a>, among others.</p> <a class=\"route-link\" href=\"/algo/en/essential-technique/binary-search-framework/\">Binary Search</a> <a class=\"route-link\" href=\"/algo/en/essential-technique/array-two-pointers-summary/\">Fast and Slow Pointers</a> <a class=\"route-link\" href=\"/algo/en/essential-technique/array-two-pointers-summary/\">Left and Right Pointers</a> <a class=\"route-link\" href=\"/algo/en/essential-technique/sliding-window-framework/\">Sliding Window</a> <a class=\"route-link\" href=\"/algo/en/data-structure/prefix-sum/\">Prefix Sum Array</a> <a class=\"route-link\" href=\"/algo/en/data-structure/diff-array/\">Difference Array</a> <p>What are the scenarios where binary search is applicable? What about difference arrays? Think through each one, and if one doesn't work, try another. You'll eventually find a relatively reliable approach.</p> <p>Let's say you determine that using a sliding window is suitable for the problem. An average person, when told to use a sliding window, might struggle to write even a line of code. But you're different. You know the framework for sliding windows, so you first write the framework and then fill it in with code.</p> <p>How do you fill it in? It's simple. The <a class=\"route-link\" href=\"/algo/en/essential-technique/sliding-window-framework/\">core framework of sliding windows</a> has been summarized. When using a sliding window, you should ask yourself three questions. Answer these questions, and you'll have solved the problem and submitted the code successfully. Isn't that satisfying?</p> <a class=\"route-link\" href=\"/algo/en/essential-technique/sliding-window-framework/\">core framework of sliding windows</a> <p>Enjoyable, right? Then I'll give you 100 <a class=\"route-link\" href=\"/algo/en/problem-set/sliding-window/\">sliding window exercises</a>. You'll solve them by following the same pattern, making minor adjustments. Does the algorithm still seem difficult to you now?</p> <a class=\"route-link\" href=\"/algo/en/problem-set/sliding-window/\">sliding window exercises</a> <h3 id=\"pitfall-four-inconsistent-problem-solving-style\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#pitfall-four-inconsistent-problem-solving-style\"><span>Pitfall Four: Inconsistent Problem-Solving Style</span></a></h3> <a class=\"header-anchor\" href=\"#pitfall-four-inconsistent-problem-solving-style\"><span>Pitfall Four: Inconsistent Problem-Solving Style</span></a> <span>Pitfall Four: Inconsistent Problem-Solving Style</span> <p>If you've avoided the previous pitfalls, you can now explore issues at a more detailed level.</p> <p>For example, when you look at solutions written by different people, their coding styles, such as algorithm frameworks and variable naming, may differ, which can create issues.</p> <p>There is no absolute right or wrong in style, but for beginners, different coding styles can increase the cost of understanding. Moreover, beginners might unconsciously adopt others' coding styles, leading to an inconsistent problem-solving style of their own, making it difficult to form a fixed routine, and reducing stability in performance.</p> <p>All algorithm frameworks and coding styles on this site maintain a consistent style, and we even explain why we use these styles. For example, <a class=\"route-link\" href=\"/algo/en/essential-technique/backtrack-vs-dfs/\">Answering Questions on Backtracking/DFS Algorithms</a> explains why the recursive function of backtracking/DFS algorithms should not have a return value.</p> <a class=\"route-link\" href=\"/algo/en/essential-technique/backtrack-vs-dfs/\">Answering Questions on Backtracking/DFS Algorithms</a> <p>I recommend beginners use a relatively consistent coding style and template. First, thoroughly understand and master the template, then you can write however you like, because you'll be able to write correctly in any style.</p> <footer class=\"vp-page-meta\"><!----><div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">Last Updated:</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>7/21/25, 11:29 AM</time></div><!----></div></footer> <div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">Last Updated:</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>7/21/25, 11:29 AM</time></div><!----></div> <div class=\"update-time\"><span class=\"vp-meta-label\">Last Updated:</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>7/21/25, 11:29 AM</time></div> <span class=\"vp-meta-label\">Last Updated:</span> <time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>7/21/25, 11:29 AM</time> <nav class=\"vp-page-nav\"><a class=\"route-link auto-link prev\" href=\"/algo/en/intro/quick-learning-plan/\" aria-label=\"Learning Plan for Quick Mastery\"><div class=\"hint\"><span class=\"arrow start\"></span>Prev</div><div class=\"link\"><!---->Learning Plan for Quick Mastery</div></a><a class=\"route-link auto-link next\" href=\"/algo/en/intro/how-to-practice/\" aria-label=\"How to Practice\"><div class=\"hint\">Next<span class=\"arrow end\"></span></div><div class=\"link\">How to Practice<!----></div></a></nav> <a class=\"route-link auto-link prev\" href=\"/algo/en/intro/quick-learning-plan/\" aria-label=\"Learning Plan for Quick Mastery\"><div class=\"hint\"><span class=\"arrow start\"></span>Prev</div><div class=\"link\"><!---->Learning Plan for Quick Mastery</div></a> <div class=\"hint\"><span class=\"arrow start\"></span>Prev</div> <span class=\"arrow start\"></span> <div class=\"link\"><!---->Learning Plan for Quick Mastery</div> <a class=\"route-link auto-link next\" href=\"/algo/en/intro/how-to-practice/\" aria-label=\"How to Practice\"><div class=\"hint\">Next<span class=\"arrow end\"></span></div><div class=\"link\">How to Practice<!----></div></a> <div class=\"hint\">Next<span class=\"arrow end\"></span></div> <span class=\"arrow end\"></span> <div class=\"link\">How to Practice<!----></div> <div style=\"justify-content:center;display:flex;\" data-v-95bd7423><div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div></div> <div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div> <div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div> <div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div>"
}