{
    "url": "https://labuladong.online/algo/data-structure-basic/huffman-tree/",
    "title": "数据压缩和霍夫曼树 | labuladong 的算法笔记",
    "content": "<nav class=\"vp-breadcrumb disable\"></nav> <div class=\"vp-page-title\"><h1><!---->数据压缩和霍夫曼树</h1><div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"作者🖊\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">原创</span><span class=\"page-word-info\" aria-label=\"字数🔠\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>约 2571 字</span><meta property=\"wordCount\" content=\"2571\"></span></div><hr></div> <h1><!---->数据压缩和霍夫曼树</h1> <div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"作者🖊\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">原创</span><span class=\"page-word-info\" aria-label=\"字数🔠\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>约 2571 字</span><meta property=\"wordCount\" content=\"2571\"></span></div> <span class=\"page-author-info\" aria-label=\"作者🖊\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg> <path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path> <span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span> <a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a> <span property=\"author\" content=\"labuladong\"></span> <span class=\"page-original-info\">原创</span> <span class=\"page-word-info\" aria-label=\"字数🔠\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>约 2571 字</span><meta property=\"wordCount\" content=\"2571\"></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg> <path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path> <path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path> <span>约 2571 字</span> <meta property=\"wordCount\" content=\"2571\"> <hr> <div class=\"\" vp-content><!----><div id=\"markdown-content\"><div class=\"hint-container info\"><p class=\"hint-container-title\">前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/binary-tree-basic/\">二叉树基础及常见类型</a></li></ul></div><div class=\"hint-container important\"><p class=\"hint-container-title\">一句话总结</p><p>霍夫曼树是二叉树结构的经典应用，它是一种最优前缀编码树，常用于数据压缩。</p></div><p>本文会介绍霍夫曼编码的原理，并对比几种常见的数据压缩思路。</p><p>具体的代码实现会放到数据结构设计章节中，带你基于霍夫曼编码实现一个压缩程序。</p><h2 id=\"浅谈数据压缩\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9\"><span>浅谈数据压缩</span></a></h2><p>我们可以把数据压缩算法分为两大类，分别是 <strong>无损压缩</strong> 和 <strong>有损压缩</strong>。</p><p><strong>无损压缩</strong> 是指压缩后的数据可以完全还原，不会丢失任何信息。</p><p>比如我们把若干文件打包成一个 zip 压缩包，这个 zip 所需的磁盘空间会更小，且解压后可以完全还原原始文件，这就叫无损压缩。</p><p><strong>有损压缩</strong> 是指压缩后的数据会丢失一些信息，但是压缩率更高（即压缩后的数据占用空间更小）。</p><p>比如我们经常会有图片压缩的需求，有些图像处理工具能够在不明显影响图片质量的前提下，显著降低图片的磁盘占用空间，这就是有损压缩。</p><p>那么我们来思考几个问题。</p><p>1、有损压缩是怎么做到在丢失信息的前提下，依然保证图片质量的呢？</p><p>2、有损压缩会丢失一些信息，换取空间的减少，这个可以理解。但无损压缩是怎么做到不丢失任何信息的前提下，压缩数据的呢？</p><p>首先，有损压缩肯定是会降低图片质量的，只不过这个降低的程度在我们的可接受范围内。</p><p>还是以图片压缩为例，人眼对「亮度」比较敏感，对「色度」不敏感。那么我们就可以用低精度的数据类型来表示「色度」，这样即便丢失了一些「色度」的信息，也几乎看不出区别。</p><p>但无损压缩不能这么搞，因为它要保证压缩后的数据可以再完全还原，所以<strong>无损压缩的本质就是编码和解码</strong>。</p><p>举个简单的例子，<code>hahahahahahaha</code> 这个字符串，我可以编码为 <code>ha*7</code>，解码时只需要把 <code>ha</code> 重复 7 次，就可以还原出原始字符串。</p><p><strong>无损压缩的效果取决于压缩算法是否能够充分挖掘出原始数据中的冗余信息</strong>。</p><p>越是通用的压缩算法，能够挖掘出的冗余信息就越少，压缩率就越低；越是专用的压缩算法，能够挖掘出的冗余信息就越多，压缩率就越高。</p><p>比方说音频文件包含声波信息，专业的音频压缩算法能够找到声波信息中的冗余进行压缩，效果就好；而通用的 zip 压缩算法将音频文件也视为普通的字节流，无法挖掘声波信息的冗余，压缩效果自然就差。</p><p>所以没有全能的压缩算法，只能在通用性、压缩率和性能之间进行权衡。</p><p>本文讲解的霍夫曼编码，就是一种通用无损压缩算法，将原始数据输入霍夫曼算法，会得到压缩后的数据和一个码表，解码时需要根据码表还原出原始数据。</p><h2 id=\"定长编码-vs-变长编码\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%AE%9A%E9%95%BF%E7%BC%96%E7%A0%81-vs-%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81\"><span>定长编码 vs 变长编码</span></a></h2><p>既然说到了编码和解码，就不得不聊一聊定长编码（fixed-length encoding）和变长编码（variable-length encoding）。</p><p>ASCII 编码是一种定长编码，它将每个字符编码为 8 位二进制数，即一个字节。</p><p>UTF-8 编码是一种变长编码，它将每个字符编码为 1 到 4 个字节。</p><p><strong>定长编码最大的优势是可以「随机访问」</strong>，因为每个字符的编码长度都是固定的，所以可以很容易地根据索引计算出字符的位置。</p><p><strong>变长编码的优势是存储效率高</strong>，比如 UTF-8 编码就是一种变长编码，存储英文字符时占用一个字节，存储中文时占用三个字节，通用性和存储效率都比 ASCII 编码强。但由于每个字符的编码长度不固定，无法通过索引进行「随机访问」。</p><p>到这里不妨思考一下，现代编辑器基本都是用 UTF-8 编码了，而对字符串进行随机访问又是编辑器的基本功能，如果每次访问都要线性扫描，显然效率很差，那么编辑器是怎么解决这个问题的呢？</p><p>回到数据压缩的场景，比方说 <code>aaabacc</code> 这个字符串有 7 个小写字母，用 ASCII 编码需要 7x8=56 bit，我现在想对它进一步压缩，应该怎么做？</p><p>因为现在只有 <code>a,b,c</code> 三种字符，所以其实不需要用 8 比特来表示每个字符，用 2 比特就够了。</p><p>比方说这样编码：</p><ul><li><code>a</code> 编码为 <code>00</code></li><li><code>b</code> 编码为 <code>01</code></li><li><code>c</code> 编码为 <code>10</code></li></ul><p>那么 <code>aaabacc</code> 就可以编码为二进制的 <code>00000001001010</code>，长度为 14 比特。</p><p>这种编码方式就叫 <strong>定长编码</strong>，因为每个字符的编码长度都固定为 2 比特。</p><p>定长编码的好处是简单，只需要知道所有可能的字符种类，就可以确定编码了。不过定长编码的压缩效果并不是很好，因为没有充分利用字符出现的频率信息。</p><p>比方说还以 <code>aaabacc</code> 为例，既然字符 <code>a</code> 出现的频率较高，<code>b,c</code> 出现的频率低，那么能否使用更短的编码来表示 <code>a</code>，让 <code>b,c</code> 使用更长的编码呢？</p><p>其实是可以的，这就叫 <strong>变长编码</strong>。比如这样编码：</p><ul><li><code>a</code> 编码为 <code>0</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>11</code></li></ul><p>那么 <code>aaabacc</code> 就可以编码为二进制的 <code>0001001111</code>，长度为 11 比特，比定长编码的压缩效果更好。</p><h2 id=\"变长编码的难点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81%E7%9A%84%E9%9A%BE%E7%82%B9\"><span>变长编码的难点</span></a></h2><div class=\"hint-container important\"><p class=\"hint-container-title\">两个难点</p><p>1、如何设计编码才能保证解码的唯一性？</p><p>2、如何保证压缩率（编码数据尽可能短）？</p><p>3、如何保证解码的效率？</p></div><p>我们仔细分析一下上面 <code>aaabacc</code> 的例子。</p><p>这种编码方案是没有歧义的：</p><ul><li><code>a</code> 编码为 <code>0</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>11</code></li></ul><p>如果把 <code>a</code> 编码为 <code>1</code>，那么编码方案中 <code>a</code> 和 <code>c</code> 的编码存在歧义：</p><ul><li><code>a</code> 编码为 <code>1</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>11</code></li></ul><p><code>aaabacc</code> 会被编码为二进制的 <code>11111011111</code>，但是 <code>a</code> 和 <code>c</code> 的编码存在歧义，<code>11</code> 既可以解码为 <code>c</code>，也可以解码为 <code>aa</code>，所以无法解码出原始数据。</p><p>对比上面两个例子可以发现一些规律：<strong>任意一个编码，都不能是另一个编码的前缀</strong>。</p><p>比如第二个例子中， <code>a</code> 编码为 <code>1</code>，而 <code>b, c</code> 编码的前缀都是 <code>1</code>，所以编码方案有歧义。</p><p>那么可能有读者会反驳，比如下面这个编码方案：</p><ul><li><code>a</code> 编码为 <code>1</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>100</code></li></ul><p>虽然出现了相同的前缀，但是我们可以在解码时添加额外的比较逻辑：</p><p>读取到 <code>1</code> 时，继续向后探测两位，看看是否可能凑出 <code>10</code> 或 <code>100</code>，进而决定如何解码。</p><p>这样确实可以保证解码唯一性，<strong>但是压缩率低，且解码效率差</strong>。向后匹配的逻辑相当于嵌套 for 循环：</p><div class=\"language-java line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"java\" style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#1E1E1E;\"><pre class=\"shiki shiki-themes light-plus dark-plus vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> i</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">0</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; i &lt; N; i++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">    for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> j</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">1</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; j &lt;= K; j++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">        ...</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">    }</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">}</span></span></code></pre><div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0;\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>假设最长的编码长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>，编码后的数据长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>，那么解码的时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NK)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span>。</p><p>如果你能保证任意一个编码都不是另一个编码的前缀，那么就不需要尝试向后匹配了。这样一来，解码的复杂度就降到了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>。</p><p>在实际的编解码场景中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 往往很大，即便 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 较小，解码速度慢几倍也是非常糟糕的，所以我们需要保证编解码算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，且压缩率尽可能高。</p><h2 class=\"hidden-for-toc\" id=\"霍夫曼编码原理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86\"><span>霍夫曼编码原理</span></a></h2><div id=\"hidden_part\" class=\"paywall\"><div><div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div><p>loading...</p></div></div></div><!----><!----><!----></div> <div id=\"markdown-content\"><div class=\"hint-container info\"><p class=\"hint-container-title\">前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/binary-tree-basic/\">二叉树基础及常见类型</a></li></ul></div><div class=\"hint-container important\"><p class=\"hint-container-title\">一句话总结</p><p>霍夫曼树是二叉树结构的经典应用，它是一种最优前缀编码树，常用于数据压缩。</p></div><p>本文会介绍霍夫曼编码的原理，并对比几种常见的数据压缩思路。</p><p>具体的代码实现会放到数据结构设计章节中，带你基于霍夫曼编码实现一个压缩程序。</p><h2 id=\"浅谈数据压缩\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9\"><span>浅谈数据压缩</span></a></h2><p>我们可以把数据压缩算法分为两大类，分别是 <strong>无损压缩</strong> 和 <strong>有损压缩</strong>。</p><p><strong>无损压缩</strong> 是指压缩后的数据可以完全还原，不会丢失任何信息。</p><p>比如我们把若干文件打包成一个 zip 压缩包，这个 zip 所需的磁盘空间会更小，且解压后可以完全还原原始文件，这就叫无损压缩。</p><p><strong>有损压缩</strong> 是指压缩后的数据会丢失一些信息，但是压缩率更高（即压缩后的数据占用空间更小）。</p><p>比如我们经常会有图片压缩的需求，有些图像处理工具能够在不明显影响图片质量的前提下，显著降低图片的磁盘占用空间，这就是有损压缩。</p><p>那么我们来思考几个问题。</p><p>1、有损压缩是怎么做到在丢失信息的前提下，依然保证图片质量的呢？</p><p>2、有损压缩会丢失一些信息，换取空间的减少，这个可以理解。但无损压缩是怎么做到不丢失任何信息的前提下，压缩数据的呢？</p><p>首先，有损压缩肯定是会降低图片质量的，只不过这个降低的程度在我们的可接受范围内。</p><p>还是以图片压缩为例，人眼对「亮度」比较敏感，对「色度」不敏感。那么我们就可以用低精度的数据类型来表示「色度」，这样即便丢失了一些「色度」的信息，也几乎看不出区别。</p><p>但无损压缩不能这么搞，因为它要保证压缩后的数据可以再完全还原，所以<strong>无损压缩的本质就是编码和解码</strong>。</p><p>举个简单的例子，<code>hahahahahahaha</code> 这个字符串，我可以编码为 <code>ha*7</code>，解码时只需要把 <code>ha</code> 重复 7 次，就可以还原出原始字符串。</p><p><strong>无损压缩的效果取决于压缩算法是否能够充分挖掘出原始数据中的冗余信息</strong>。</p><p>越是通用的压缩算法，能够挖掘出的冗余信息就越少，压缩率就越低；越是专用的压缩算法，能够挖掘出的冗余信息就越多，压缩率就越高。</p><p>比方说音频文件包含声波信息，专业的音频压缩算法能够找到声波信息中的冗余进行压缩，效果就好；而通用的 zip 压缩算法将音频文件也视为普通的字节流，无法挖掘声波信息的冗余，压缩效果自然就差。</p><p>所以没有全能的压缩算法，只能在通用性、压缩率和性能之间进行权衡。</p><p>本文讲解的霍夫曼编码，就是一种通用无损压缩算法，将原始数据输入霍夫曼算法，会得到压缩后的数据和一个码表，解码时需要根据码表还原出原始数据。</p><h2 id=\"定长编码-vs-变长编码\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%AE%9A%E9%95%BF%E7%BC%96%E7%A0%81-vs-%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81\"><span>定长编码 vs 变长编码</span></a></h2><p>既然说到了编码和解码，就不得不聊一聊定长编码（fixed-length encoding）和变长编码（variable-length encoding）。</p><p>ASCII 编码是一种定长编码，它将每个字符编码为 8 位二进制数，即一个字节。</p><p>UTF-8 编码是一种变长编码，它将每个字符编码为 1 到 4 个字节。</p><p><strong>定长编码最大的优势是可以「随机访问」</strong>，因为每个字符的编码长度都是固定的，所以可以很容易地根据索引计算出字符的位置。</p><p><strong>变长编码的优势是存储效率高</strong>，比如 UTF-8 编码就是一种变长编码，存储英文字符时占用一个字节，存储中文时占用三个字节，通用性和存储效率都比 ASCII 编码强。但由于每个字符的编码长度不固定，无法通过索引进行「随机访问」。</p><p>到这里不妨思考一下，现代编辑器基本都是用 UTF-8 编码了，而对字符串进行随机访问又是编辑器的基本功能，如果每次访问都要线性扫描，显然效率很差，那么编辑器是怎么解决这个问题的呢？</p><p>回到数据压缩的场景，比方说 <code>aaabacc</code> 这个字符串有 7 个小写字母，用 ASCII 编码需要 7x8=56 bit，我现在想对它进一步压缩，应该怎么做？</p><p>因为现在只有 <code>a,b,c</code> 三种字符，所以其实不需要用 8 比特来表示每个字符，用 2 比特就够了。</p><p>比方说这样编码：</p><ul><li><code>a</code> 编码为 <code>00</code></li><li><code>b</code> 编码为 <code>01</code></li><li><code>c</code> 编码为 <code>10</code></li></ul><p>那么 <code>aaabacc</code> 就可以编码为二进制的 <code>00000001001010</code>，长度为 14 比特。</p><p>这种编码方式就叫 <strong>定长编码</strong>，因为每个字符的编码长度都固定为 2 比特。</p><p>定长编码的好处是简单，只需要知道所有可能的字符种类，就可以确定编码了。不过定长编码的压缩效果并不是很好，因为没有充分利用字符出现的频率信息。</p><p>比方说还以 <code>aaabacc</code> 为例，既然字符 <code>a</code> 出现的频率较高，<code>b,c</code> 出现的频率低，那么能否使用更短的编码来表示 <code>a</code>，让 <code>b,c</code> 使用更长的编码呢？</p><p>其实是可以的，这就叫 <strong>变长编码</strong>。比如这样编码：</p><ul><li><code>a</code> 编码为 <code>0</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>11</code></li></ul><p>那么 <code>aaabacc</code> 就可以编码为二进制的 <code>0001001111</code>，长度为 11 比特，比定长编码的压缩效果更好。</p><h2 id=\"变长编码的难点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81%E7%9A%84%E9%9A%BE%E7%82%B9\"><span>变长编码的难点</span></a></h2><div class=\"hint-container important\"><p class=\"hint-container-title\">两个难点</p><p>1、如何设计编码才能保证解码的唯一性？</p><p>2、如何保证压缩率（编码数据尽可能短）？</p><p>3、如何保证解码的效率？</p></div><p>我们仔细分析一下上面 <code>aaabacc</code> 的例子。</p><p>这种编码方案是没有歧义的：</p><ul><li><code>a</code> 编码为 <code>0</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>11</code></li></ul><p>如果把 <code>a</code> 编码为 <code>1</code>，那么编码方案中 <code>a</code> 和 <code>c</code> 的编码存在歧义：</p><ul><li><code>a</code> 编码为 <code>1</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>11</code></li></ul><p><code>aaabacc</code> 会被编码为二进制的 <code>11111011111</code>，但是 <code>a</code> 和 <code>c</code> 的编码存在歧义，<code>11</code> 既可以解码为 <code>c</code>，也可以解码为 <code>aa</code>，所以无法解码出原始数据。</p><p>对比上面两个例子可以发现一些规律：<strong>任意一个编码，都不能是另一个编码的前缀</strong>。</p><p>比如第二个例子中， <code>a</code> 编码为 <code>1</code>，而 <code>b, c</code> 编码的前缀都是 <code>1</code>，所以编码方案有歧义。</p><p>那么可能有读者会反驳，比如下面这个编码方案：</p><ul><li><code>a</code> 编码为 <code>1</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>100</code></li></ul><p>虽然出现了相同的前缀，但是我们可以在解码时添加额外的比较逻辑：</p><p>读取到 <code>1</code> 时，继续向后探测两位，看看是否可能凑出 <code>10</code> 或 <code>100</code>，进而决定如何解码。</p><p>这样确实可以保证解码唯一性，<strong>但是压缩率低，且解码效率差</strong>。向后匹配的逻辑相当于嵌套 for 循环：</p><div class=\"language-java line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"java\" style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#1E1E1E;\"><pre class=\"shiki shiki-themes light-plus dark-plus vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> i</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">0</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; i &lt; N; i++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">    for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> j</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">1</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; j &lt;= K; j++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">        ...</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">    }</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">}</span></span></code></pre><div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0;\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>假设最长的编码长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>，编码后的数据长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>，那么解码的时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NK)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span>。</p><p>如果你能保证任意一个编码都不是另一个编码的前缀，那么就不需要尝试向后匹配了。这样一来，解码的复杂度就降到了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>。</p><p>在实际的编解码场景中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 往往很大，即便 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 较小，解码速度慢几倍也是非常糟糕的，所以我们需要保证编解码算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，且压缩率尽可能高。</p><h2 class=\"hidden-for-toc\" id=\"霍夫曼编码原理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86\"><span>霍夫曼编码原理</span></a></h2><div id=\"hidden_part\" class=\"paywall\"><div><div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div><p>loading...</p></div></div></div> <div class=\"hint-container info\"><p class=\"hint-container-title\">前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/binary-tree-basic/\">二叉树基础及常见类型</a></li></ul></div> <p class=\"hint-container-title\">前置知识</p> <p>阅读本文前，你需要先学习：</p> <ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/binary-tree-basic/\">二叉树基础及常见类型</a></li></ul> <li><a class=\"route-link\" href=\"/algo/data-structure-basic/binary-tree-basic/\">二叉树基础及常见类型</a></li> <a class=\"route-link\" href=\"/algo/data-structure-basic/binary-tree-basic/\">二叉树基础及常见类型</a> <div class=\"hint-container important\"><p class=\"hint-container-title\">一句话总结</p><p>霍夫曼树是二叉树结构的经典应用，它是一种最优前缀编码树，常用于数据压缩。</p></div> <p class=\"hint-container-title\">一句话总结</p> <p>霍夫曼树是二叉树结构的经典应用，它是一种最优前缀编码树，常用于数据压缩。</p> <p>本文会介绍霍夫曼编码的原理，并对比几种常见的数据压缩思路。</p> <p>具体的代码实现会放到数据结构设计章节中，带你基于霍夫曼编码实现一个压缩程序。</p> <h2 id=\"浅谈数据压缩\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9\"><span>浅谈数据压缩</span></a></h2> <a class=\"header-anchor\" href=\"#%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9\"><span>浅谈数据压缩</span></a> <span>浅谈数据压缩</span> <p>我们可以把数据压缩算法分为两大类，分别是 <strong>无损压缩</strong> 和 <strong>有损压缩</strong>。</p> <strong>无损压缩</strong> <strong>有损压缩</strong> <p><strong>无损压缩</strong> 是指压缩后的数据可以完全还原，不会丢失任何信息。</p> <strong>无损压缩</strong> <p>比如我们把若干文件打包成一个 zip 压缩包，这个 zip 所需的磁盘空间会更小，且解压后可以完全还原原始文件，这就叫无损压缩。</p> <p><strong>有损压缩</strong> 是指压缩后的数据会丢失一些信息，但是压缩率更高（即压缩后的数据占用空间更小）。</p> <strong>有损压缩</strong> <p>比如我们经常会有图片压缩的需求，有些图像处理工具能够在不明显影响图片质量的前提下，显著降低图片的磁盘占用空间，这就是有损压缩。</p> <p>那么我们来思考几个问题。</p> <p>1、有损压缩是怎么做到在丢失信息的前提下，依然保证图片质量的呢？</p> <p>2、有损压缩会丢失一些信息，换取空间的减少，这个可以理解。但无损压缩是怎么做到不丢失任何信息的前提下，压缩数据的呢？</p> <p>首先，有损压缩肯定是会降低图片质量的，只不过这个降低的程度在我们的可接受范围内。</p> <p>还是以图片压缩为例，人眼对「亮度」比较敏感，对「色度」不敏感。那么我们就可以用低精度的数据类型来表示「色度」，这样即便丢失了一些「色度」的信息，也几乎看不出区别。</p> <p>但无损压缩不能这么搞，因为它要保证压缩后的数据可以再完全还原，所以<strong>无损压缩的本质就是编码和解码</strong>。</p> <strong>无损压缩的本质就是编码和解码</strong> <p>举个简单的例子，<code>hahahahahahaha</code> 这个字符串，我可以编码为 <code>ha*7</code>，解码时只需要把 <code>ha</code> 重复 7 次，就可以还原出原始字符串。</p> <code>hahahahahahaha</code> <code>ha*7</code> <code>ha</code> <p><strong>无损压缩的效果取决于压缩算法是否能够充分挖掘出原始数据中的冗余信息</strong>。</p> <strong>无损压缩的效果取决于压缩算法是否能够充分挖掘出原始数据中的冗余信息</strong> <p>越是通用的压缩算法，能够挖掘出的冗余信息就越少，压缩率就越低；越是专用的压缩算法，能够挖掘出的冗余信息就越多，压缩率就越高。</p> <p>比方说音频文件包含声波信息，专业的音频压缩算法能够找到声波信息中的冗余进行压缩，效果就好；而通用的 zip 压缩算法将音频文件也视为普通的字节流，无法挖掘声波信息的冗余，压缩效果自然就差。</p> <p>所以没有全能的压缩算法，只能在通用性、压缩率和性能之间进行权衡。</p> <p>本文讲解的霍夫曼编码，就是一种通用无损压缩算法，将原始数据输入霍夫曼算法，会得到压缩后的数据和一个码表，解码时需要根据码表还原出原始数据。</p> <h2 id=\"定长编码-vs-变长编码\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%AE%9A%E9%95%BF%E7%BC%96%E7%A0%81-vs-%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81\"><span>定长编码 vs 变长编码</span></a></h2> <a class=\"header-anchor\" href=\"#%E5%AE%9A%E9%95%BF%E7%BC%96%E7%A0%81-vs-%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81\"><span>定长编码 vs 变长编码</span></a> <span>定长编码 vs 变长编码</span> <p>既然说到了编码和解码，就不得不聊一聊定长编码（fixed-length encoding）和变长编码（variable-length encoding）。</p> <p>ASCII 编码是一种定长编码，它将每个字符编码为 8 位二进制数，即一个字节。</p> <p>UTF-8 编码是一种变长编码，它将每个字符编码为 1 到 4 个字节。</p> <p><strong>定长编码最大的优势是可以「随机访问」</strong>，因为每个字符的编码长度都是固定的，所以可以很容易地根据索引计算出字符的位置。</p> <strong>定长编码最大的优势是可以「随机访问」</strong> <p><strong>变长编码的优势是存储效率高</strong>，比如 UTF-8 编码就是一种变长编码，存储英文字符时占用一个字节，存储中文时占用三个字节，通用性和存储效率都比 ASCII 编码强。但由于每个字符的编码长度不固定，无法通过索引进行「随机访问」。</p> <strong>变长编码的优势是存储效率高</strong> <p>到这里不妨思考一下，现代编辑器基本都是用 UTF-8 编码了，而对字符串进行随机访问又是编辑器的基本功能，如果每次访问都要线性扫描，显然效率很差，那么编辑器是怎么解决这个问题的呢？</p> <p>回到数据压缩的场景，比方说 <code>aaabacc</code> 这个字符串有 7 个小写字母，用 ASCII 编码需要 7x8=56 bit，我现在想对它进一步压缩，应该怎么做？</p> <code>aaabacc</code> <p>因为现在只有 <code>a,b,c</code> 三种字符，所以其实不需要用 8 比特来表示每个字符，用 2 比特就够了。</p> <code>a,b,c</code> <p>比方说这样编码：</p> <ul><li><code>a</code> 编码为 <code>00</code></li><li><code>b</code> 编码为 <code>01</code></li><li><code>c</code> 编码为 <code>10</code></li></ul> <li><code>a</code> 编码为 <code>00</code></li> <code>a</code> <code>00</code> <li><code>b</code> 编码为 <code>01</code></li> <code>b</code> <code>01</code> <li><code>c</code> 编码为 <code>10</code></li> <code>c</code> <code>10</code> <p>那么 <code>aaabacc</code> 就可以编码为二进制的 <code>00000001001010</code>，长度为 14 比特。</p> <code>aaabacc</code> <code>00000001001010</code> <p>这种编码方式就叫 <strong>定长编码</strong>，因为每个字符的编码长度都固定为 2 比特。</p> <strong>定长编码</strong> <p>定长编码的好处是简单，只需要知道所有可能的字符种类，就可以确定编码了。不过定长编码的压缩效果并不是很好，因为没有充分利用字符出现的频率信息。</p> <p>比方说还以 <code>aaabacc</code> 为例，既然字符 <code>a</code> 出现的频率较高，<code>b,c</code> 出现的频率低，那么能否使用更短的编码来表示 <code>a</code>，让 <code>b,c</code> 使用更长的编码呢？</p> <code>aaabacc</code> <code>a</code> <code>b,c</code> <code>a</code> <code>b,c</code> <p>其实是可以的，这就叫 <strong>变长编码</strong>。比如这样编码：</p> <strong>变长编码</strong> <ul><li><code>a</code> 编码为 <code>0</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>11</code></li></ul> <li><code>a</code> 编码为 <code>0</code></li> <code>a</code> <code>0</code> <li><code>b</code> 编码为 <code>10</code></li> <code>b</code> <code>10</code> <li><code>c</code> 编码为 <code>11</code></li> <code>c</code> <code>11</code> <p>那么 <code>aaabacc</code> 就可以编码为二进制的 <code>0001001111</code>，长度为 11 比特，比定长编码的压缩效果更好。</p> <code>aaabacc</code> <code>0001001111</code> <h2 id=\"变长编码的难点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81%E7%9A%84%E9%9A%BE%E7%82%B9\"><span>变长编码的难点</span></a></h2> <a class=\"header-anchor\" href=\"#%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81%E7%9A%84%E9%9A%BE%E7%82%B9\"><span>变长编码的难点</span></a> <span>变长编码的难点</span> <div class=\"hint-container important\"><p class=\"hint-container-title\">两个难点</p><p>1、如何设计编码才能保证解码的唯一性？</p><p>2、如何保证压缩率（编码数据尽可能短）？</p><p>3、如何保证解码的效率？</p></div> <p class=\"hint-container-title\">两个难点</p> <p>1、如何设计编码才能保证解码的唯一性？</p> <p>2、如何保证压缩率（编码数据尽可能短）？</p> <p>3、如何保证解码的效率？</p> <p>我们仔细分析一下上面 <code>aaabacc</code> 的例子。</p> <code>aaabacc</code> <p>这种编码方案是没有歧义的：</p> <ul><li><code>a</code> 编码为 <code>0</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>11</code></li></ul> <li><code>a</code> 编码为 <code>0</code></li> <code>a</code> <code>0</code> <li><code>b</code> 编码为 <code>10</code></li> <code>b</code> <code>10</code> <li><code>c</code> 编码为 <code>11</code></li> <code>c</code> <code>11</code> <p>如果把 <code>a</code> 编码为 <code>1</code>，那么编码方案中 <code>a</code> 和 <code>c</code> 的编码存在歧义：</p> <code>a</code> <code>1</code> <code>a</code> <code>c</code> <ul><li><code>a</code> 编码为 <code>1</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>11</code></li></ul> <li><code>a</code> 编码为 <code>1</code></li> <code>a</code> <code>1</code> <li><code>b</code> 编码为 <code>10</code></li> <code>b</code> <code>10</code> <li><code>c</code> 编码为 <code>11</code></li> <code>c</code> <code>11</code> <p><code>aaabacc</code> 会被编码为二进制的 <code>11111011111</code>，但是 <code>a</code> 和 <code>c</code> 的编码存在歧义，<code>11</code> 既可以解码为 <code>c</code>，也可以解码为 <code>aa</code>，所以无法解码出原始数据。</p> <code>aaabacc</code> <code>11111011111</code> <code>a</code> <code>c</code> <code>11</code> <code>c</code> <code>aa</code> <p>对比上面两个例子可以发现一些规律：<strong>任意一个编码，都不能是另一个编码的前缀</strong>。</p> <strong>任意一个编码，都不能是另一个编码的前缀</strong> <p>比如第二个例子中， <code>a</code> 编码为 <code>1</code>，而 <code>b, c</code> 编码的前缀都是 <code>1</code>，所以编码方案有歧义。</p> <code>a</code> <code>1</code> <code>b, c</code> <code>1</code> <p>那么可能有读者会反驳，比如下面这个编码方案：</p> <ul><li><code>a</code> 编码为 <code>1</code></li><li><code>b</code> 编码为 <code>10</code></li><li><code>c</code> 编码为 <code>100</code></li></ul> <li><code>a</code> 编码为 <code>1</code></li> <code>a</code> <code>1</code> <li><code>b</code> 编码为 <code>10</code></li> <code>b</code> <code>10</code> <li><code>c</code> 编码为 <code>100</code></li> <code>c</code> <code>100</code> <p>虽然出现了相同的前缀，但是我们可以在解码时添加额外的比较逻辑：</p> <p>读取到 <code>1</code> 时，继续向后探测两位，看看是否可能凑出 <code>10</code> 或 <code>100</code>，进而决定如何解码。</p> <code>1</code> <code>10</code> <code>100</code> <p>这样确实可以保证解码唯一性，<strong>但是压缩率低，且解码效率差</strong>。向后匹配的逻辑相当于嵌套 for 循环：</p> <strong>但是压缩率低，且解码效率差</strong> <div class=\"language-java line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"java\" style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#1E1E1E;\"><pre class=\"shiki shiki-themes light-plus dark-plus vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> i</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">0</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; i &lt; N; i++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">    for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> j</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">1</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; j &lt;= K; j++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">        ...</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">    }</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">}</span></span></code></pre><div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0;\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div> <pre class=\"shiki shiki-themes light-plus dark-plus vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> i</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">0</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; i &lt; N; i++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">    for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> j</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">1</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; j &lt;= K; j++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">        ...</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">    }</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">}</span></span></code></pre> <code><span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> i</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">0</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; i &lt; N; i++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">    for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> j</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">1</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; j &lt;= K; j++) {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">        ...</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">    }</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">}</span></span></code> <span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> i</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">0</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; i &lt; N; i++) {</span></span> <span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">for</span> <span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span> <span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span> <span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> i</span> <span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span> <span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">0</span> <span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; i &lt; N; i++) {</span> <span class=\"line\"><span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">    for</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span><span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span><span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> j</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span><span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">1</span><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; j &lt;= K; j++) {</span></span> <span style=\"--shiki-light:#AF00DB;--shiki-dark:#C586C0;\">    for</span> <span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> (</span> <span style=\"--shiki-light:#267F99;--shiki-dark:#4EC9B0;\">int</span> <span style=\"--shiki-light:#001080;--shiki-dark:#9CDCFE;\"> j</span> <span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\"> = </span> <span style=\"--shiki-light:#098658;--shiki-dark:#B5CEA8;\">1</span> <span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">; j &lt;= K; j++) {</span> <span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">        ...</span></span> <span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">        ...</span> <span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">    }</span></span> <span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">    }</span> <span class=\"line\"><span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">}</span></span> <span style=\"--shiki-light:#000000;--shiki-dark:#D4D4D4;\">}</span> <div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0;\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div> <div class=\"line-number\"></div> <div class=\"line-number\"></div> <div class=\"line-number\"></div> <div class=\"line-number\"></div> <div class=\"line-number\"></div> <p>假设最长的编码长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>，编码后的数据长度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>，那么解码的时间复杂度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NK)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span>。</p> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math> <semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics> <mrow><mi>K</mi></mrow> <mi>K</mi> <annotation encoding=\"application/x-tex\">K</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math> <semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics> <mrow><mi>N</mi></mrow> <mi>N</mi> <annotation encoding=\"application/x-tex\">N</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NK)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NK)</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NK)</annotation></semantics></math> <semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>K</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NK)</annotation></semantics> <mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>K</mi><mo stretchy=\"false\">)</mo></mrow> <mi>O</mi> <mo stretchy=\"false\">(</mo> <mi>N</mi> <mi>K</mi> <mo stretchy=\"false\">)</mo> <annotation encoding=\"application/x-tex\">O(NK)</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)</span></span> <span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span> <span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span> <span class=\"mopen\">(</span> <span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span> <span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span> <span class=\"mclose\">)</span> <p>如果你能保证任意一个编码都不是另一个编码的前缀，那么就不需要尝试向后匹配了。这样一来，解码的复杂度就降到了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>。</p> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math> <semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics> <mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow> <mi>O</mi> <mo stretchy=\"false\">(</mo> <mi>N</mi> <mo stretchy=\"false\">)</mo> <annotation encoding=\"application/x-tex\">O(N)</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span> <span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span> <span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span> <span class=\"mopen\">(</span> <span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span> <span class=\"mclose\">)</span> <p>在实际的编解码场景中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 往往很大，即便 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 较小，解码速度慢几倍也是非常糟糕的，所以我们需要保证编解码算法的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，且压缩率尽可能高。</p> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math> <semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics> <mrow><mi>N</mi></mrow> <mi>N</mi> <annotation encoding=\"application/x-tex\">N</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math> <semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics> <mrow><mi>K</mi></mrow> <mi>K</mi> <annotation encoding=\"application/x-tex\">K</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math> <semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics> <mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow> <mi>O</mi> <mo stretchy=\"false\">(</mo> <mi>N</mi> <mo stretchy=\"false\">)</mo> <annotation encoding=\"application/x-tex\">O(N)</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span> <span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span> <span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span> <span class=\"mopen\">(</span> <span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span> <span class=\"mclose\">)</span> <h2 class=\"hidden-for-toc\" id=\"霍夫曼编码原理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86\"><span>霍夫曼编码原理</span></a></h2> <a class=\"header-anchor\" href=\"#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86\"><span>霍夫曼编码原理</span></a> <span>霍夫曼编码原理</span> <div id=\"hidden_part\" class=\"paywall\"><div><div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div><p>loading...</p></div></div> <div><div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div><p>loading...</p></div> <div class=\"css-1p3hq3p ant-spin ant-spin-spinning\" aria-live=\"polite\" aria-busy=\"true\"><span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span><!----></div> <span class=\"ant-spin-dot ant-spin-dot-spin\"><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i><i class=\"ant-spin-dot-item\"></i></span> <i class=\"ant-spin-dot-item\"></i> <i class=\"ant-spin-dot-item\"></i> <i class=\"ant-spin-dot-item\"></i> <i class=\"ant-spin-dot-item\"></i> <p>loading...</p> <footer class=\"vp-page-meta\"><!----><div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">最近更新：</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time></div><!----></div></footer> <div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">最近更新：</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time></div><!----></div> <div class=\"update-time\"><span class=\"vp-meta-label\">最近更新：</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time></div> <span class=\"vp-meta-label\">最近更新：</span> <time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time> <nav class=\"vp-page-nav\"><a class=\"route-link auto-link prev\" href=\"/algo/data-structure-basic/segment-tree-basic/\" aria-label=\"线段树核心原理及可视化\"><div class=\"hint\"><span class=\"arrow start\"></span>上一页</div><div class=\"link\"><!---->线段树核心原理及可视化</div></a><a class=\"route-link auto-link next\" href=\"/algo/intro/updating/\" aria-label=\"正在更新 ing\"><div class=\"hint\">下一页<span class=\"arrow end\"></span></div><div class=\"link\">正在更新 ing<!----></div></a></nav> <a class=\"route-link auto-link prev\" href=\"/algo/data-structure-basic/segment-tree-basic/\" aria-label=\"线段树核心原理及可视化\"><div class=\"hint\"><span class=\"arrow start\"></span>上一页</div><div class=\"link\"><!---->线段树核心原理及可视化</div></a> <div class=\"hint\"><span class=\"arrow start\"></span>上一页</div> <span class=\"arrow start\"></span> <div class=\"link\"><!---->线段树核心原理及可视化</div> <a class=\"route-link auto-link next\" href=\"/algo/intro/updating/\" aria-label=\"正在更新 ing\"><div class=\"hint\">下一页<span class=\"arrow end\"></span></div><div class=\"link\">正在更新 ing<!----></div></a> <div class=\"hint\">下一页<span class=\"arrow end\"></span></div> <span class=\"arrow end\"></span> <div class=\"link\">正在更新 ing<!----></div> <div style=\"justify-content:center;display:flex;\" data-v-95bd7423><div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div></div> <div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div> <div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div> <div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div>"
}