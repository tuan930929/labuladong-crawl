{
    "url": "https://labuladong.online/algo/data-structure-basic/graph-minimum-spanning-tree/",
    "title": "最小生成树算法概览 | labuladong 的算法笔记",
    "content": "<nav class=\"vp-breadcrumb disable\"></nav> <div class=\"vp-page-title\"><h1><!---->最小生成树算法概览</h1><div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"作者🖊\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">原创</span><span class=\"page-word-info\" aria-label=\"字数🔠\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>约 1224 字</span><meta property=\"wordCount\" content=\"1224\"></span></div><hr></div> <h1><!---->最小生成树算法概览</h1> <div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"作者🖊\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">原创</span><span class=\"page-word-info\" aria-label=\"字数🔠\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>约 1224 字</span><meta property=\"wordCount\" content=\"1224\"></span></div> <span class=\"page-author-info\" aria-label=\"作者🖊\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg> <path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path> <span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span> <a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a> <span property=\"author\" content=\"labuladong\"></span> <span class=\"page-original-info\">原创</span> <span class=\"page-word-info\" aria-label=\"字数🔠\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>约 1224 字</span><meta property=\"wordCount\" content=\"1224\"></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg> <path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path> <path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path> <span>约 1224 字</span> <meta property=\"wordCount\" content=\"1224\"> <hr> <div class=\"\" vp-content><!----><div id=\"markdown-content\"><div class=\"hint-container info\"><p class=\"hint-container-title\">前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-terminology/\">图结构术语</a></li></ul></div><p>最小生成树是图论中的经典问题，在现实生活中有广泛的应用，比如设计最低成本的通信网络、电路布线、管道铺设等。</p><p>考虑到最小生成树的算法实现需要一些其他算法作为铺垫，且本文处在基础章节，所以不会详细讲解算法代码。</p><p>本文主要介绍最小生成树的定义及应用场景，并阐述两种经典的最小生成树算法的核心原理。具体的代码实现安排在数据结构设计章节。</p><h2 id=\"什么是生成树\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E6%A0%91\"><span>什么是生成树</span></a></h2><p>首先理解什么是生成树。给定一个无向连通图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>，其<strong>生成树</strong>是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 的一个子图，它包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 中的所有顶点，并且是一棵树（即无环连通图）。</p><p>换句话说，生成树具有以下特性：</p><ul><li>包含原图中的所有顶点。</li><li>边的数量为顶点数减一（<code>V-1</code>条边）。</li><li>连通且无环。</li></ul><p>一个图可以有多个不同的生成树，例如这幅加权图：</p><!----><p>可以有以下生成树，其中属于生成树的边被标记为了红色：</p><!----><p>下面是一个不同的生成树：</p><!----><h2 id=\"什么是最小生成树\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span>什么是最小生成树</span></a></h2><p>如果图是加权图，那么<strong>最小生成树</strong>就是边权重总和最小的生成树。</p><p>比如上面展示的例子，第二种生成树是该图的最小生成树，总权重为：2 + 3 + 5 = 10，没有其他的生成树能够得到更小的权重和了。</p><p>最小生成树在现实生活中有很多应用场景，边的权重可能代表距离、成本、时间等。</p><p>比方说想在若干城市之间修建公路，图中的节点代表城市，边代表城市之间的公路，边的权重代表修建公路的成本，我们希望找到一种方案能够连接所有城市，且总成本最小，这就是典型的最小生成树问题。</p><h2 id=\"最小生成树算法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95\"><span>最小生成树算法</span></a></h2><p>有两种经典的算法用于求解最小生成树问题：Kruskal 算法和 Prim 算法。它们都基于贪心思想，但实现方式不同。</p><p>Kruskal 算法相对简单一些，只需要先对图中的所有边按照权重排序，然后借助 <a class=\"route-link\" href=\"/algo/data-structure/union-find/\">Union-Find 并查集算法</a> 即可找到最小生成树。</p><p>Prim 算法可以由 <a class=\"route-link\" href=\"/algo/data-structure/dijkstra/\">Dijkstra 算法</a> 拓展而来，借助 <a class=\"route-link\" href=\"/algo/data-structure-basic/binary-heap-basic/\">优先级队列</a> 动态排序的特性，逐步构造最小生成树。</p><p>具体的代码实现在 <a class=\"route-link\" href=\"/algo/data-structure/kruskal/\">Kruskal 算法</a> 和 <a class=\"route-link\" href=\"/algo/data-structure/prim/\">Prim 算法</a> 中讲解。</p><h2 id=\"随机地图构造问题\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%9B%BE%E6%9E%84%E9%80%A0%E9%97%AE%E9%A2%98\"><span>随机地图构造问题</span></a></h2><p>最小生成树算法经过一些巧妙的改造后，可以被用于生成游戏中的随机化迷宫、洞穴等场景。</p><p>其核心思想是利用最小生成树算法<strong>能够连接所有顶点且无环路</strong>的特性，来确保生成地图的连通性。通过引入随机性，可以创造出每次都不同、看起来自然且复杂的地图结构。</p><p>本站包含一个迷宫小游戏，要求你编写 <code>mazeGenerate</code> 函数生成迷宫地图，要求必须存在至少一条起点到终点的路径，且地图需要尽可能随机：</p><!----><p>我们可以借助游戏面板直观体会一下最小生成树算法生成的地图的特点。</p><p>在游戏面板中可以选择「生成算法」和「求解算法」，你可以切换不同的生成算法，然后点击「生成」按钮，即可查看不同的算法生成地图的过程。</p><p>先来观察 Krusual 算法，地图被初始化为一个网格图结构，然后从图中的多个位置开始出现随机路径，最终连接成一个完整的迷宫地图。</p><p>再来观察 Prim 算法，地图的初始状态全部都是障碍物，然后从起点开始向周围扩展路径，最终连接成一个完整的迷宫地图。</p><p>不只是生成地图的过程不同，生成的地图特点也不同。你可以在游戏面板上切换不同的求解算法，点击「求解」按钮，即可对比查看不同的算法求解地图的过程。</p><p>我会建议观察 BFS/DFS 算法求解地图的过程，仔细体会一下不同算法生成地图的特点。在后文讲解完最小生成树算法实现之后，我们再具体讲解随机迷宫地图的生成算法。</p></div><!----><!----><!----></div> <div id=\"markdown-content\"><div class=\"hint-container info\"><p class=\"hint-container-title\">前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-terminology/\">图结构术语</a></li></ul></div><p>最小生成树是图论中的经典问题，在现实生活中有广泛的应用，比如设计最低成本的通信网络、电路布线、管道铺设等。</p><p>考虑到最小生成树的算法实现需要一些其他算法作为铺垫，且本文处在基础章节，所以不会详细讲解算法代码。</p><p>本文主要介绍最小生成树的定义及应用场景，并阐述两种经典的最小生成树算法的核心原理。具体的代码实现安排在数据结构设计章节。</p><h2 id=\"什么是生成树\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E6%A0%91\"><span>什么是生成树</span></a></h2><p>首先理解什么是生成树。给定一个无向连通图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>，其<strong>生成树</strong>是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 的一个子图，它包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 中的所有顶点，并且是一棵树（即无环连通图）。</p><p>换句话说，生成树具有以下特性：</p><ul><li>包含原图中的所有顶点。</li><li>边的数量为顶点数减一（<code>V-1</code>条边）。</li><li>连通且无环。</li></ul><p>一个图可以有多个不同的生成树，例如这幅加权图：</p><!----><p>可以有以下生成树，其中属于生成树的边被标记为了红色：</p><!----><p>下面是一个不同的生成树：</p><!----><h2 id=\"什么是最小生成树\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span>什么是最小生成树</span></a></h2><p>如果图是加权图，那么<strong>最小生成树</strong>就是边权重总和最小的生成树。</p><p>比如上面展示的例子，第二种生成树是该图的最小生成树，总权重为：2 + 3 + 5 = 10，没有其他的生成树能够得到更小的权重和了。</p><p>最小生成树在现实生活中有很多应用场景，边的权重可能代表距离、成本、时间等。</p><p>比方说想在若干城市之间修建公路，图中的节点代表城市，边代表城市之间的公路，边的权重代表修建公路的成本，我们希望找到一种方案能够连接所有城市，且总成本最小，这就是典型的最小生成树问题。</p><h2 id=\"最小生成树算法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95\"><span>最小生成树算法</span></a></h2><p>有两种经典的算法用于求解最小生成树问题：Kruskal 算法和 Prim 算法。它们都基于贪心思想，但实现方式不同。</p><p>Kruskal 算法相对简单一些，只需要先对图中的所有边按照权重排序，然后借助 <a class=\"route-link\" href=\"/algo/data-structure/union-find/\">Union-Find 并查集算法</a> 即可找到最小生成树。</p><p>Prim 算法可以由 <a class=\"route-link\" href=\"/algo/data-structure/dijkstra/\">Dijkstra 算法</a> 拓展而来，借助 <a class=\"route-link\" href=\"/algo/data-structure-basic/binary-heap-basic/\">优先级队列</a> 动态排序的特性，逐步构造最小生成树。</p><p>具体的代码实现在 <a class=\"route-link\" href=\"/algo/data-structure/kruskal/\">Kruskal 算法</a> 和 <a class=\"route-link\" href=\"/algo/data-structure/prim/\">Prim 算法</a> 中讲解。</p><h2 id=\"随机地图构造问题\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%9B%BE%E6%9E%84%E9%80%A0%E9%97%AE%E9%A2%98\"><span>随机地图构造问题</span></a></h2><p>最小生成树算法经过一些巧妙的改造后，可以被用于生成游戏中的随机化迷宫、洞穴等场景。</p><p>其核心思想是利用最小生成树算法<strong>能够连接所有顶点且无环路</strong>的特性，来确保生成地图的连通性。通过引入随机性，可以创造出每次都不同、看起来自然且复杂的地图结构。</p><p>本站包含一个迷宫小游戏，要求你编写 <code>mazeGenerate</code> 函数生成迷宫地图，要求必须存在至少一条起点到终点的路径，且地图需要尽可能随机：</p><!----><p>我们可以借助游戏面板直观体会一下最小生成树算法生成的地图的特点。</p><p>在游戏面板中可以选择「生成算法」和「求解算法」，你可以切换不同的生成算法，然后点击「生成」按钮，即可查看不同的算法生成地图的过程。</p><p>先来观察 Krusual 算法，地图被初始化为一个网格图结构，然后从图中的多个位置开始出现随机路径，最终连接成一个完整的迷宫地图。</p><p>再来观察 Prim 算法，地图的初始状态全部都是障碍物，然后从起点开始向周围扩展路径，最终连接成一个完整的迷宫地图。</p><p>不只是生成地图的过程不同，生成的地图特点也不同。你可以在游戏面板上切换不同的求解算法，点击「求解」按钮，即可对比查看不同的算法求解地图的过程。</p><p>我会建议观察 BFS/DFS 算法求解地图的过程，仔细体会一下不同算法生成地图的特点。在后文讲解完最小生成树算法实现之后，我们再具体讲解随机迷宫地图的生成算法。</p></div> <div class=\"hint-container info\"><p class=\"hint-container-title\">前置知识</p><p>阅读本文前，你需要先学习：</p><ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-terminology/\">图结构术语</a></li></ul></div> <p class=\"hint-container-title\">前置知识</p> <p>阅读本文前，你需要先学习：</p> <ul><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li><li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-terminology/\">图结构术语</a></li></ul> <li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a></li> <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-basic/\">图结构基础及通用代码实现</a> <li><a class=\"route-link\" href=\"/algo/data-structure-basic/graph-terminology/\">图结构术语</a></li> <a class=\"route-link\" href=\"/algo/data-structure-basic/graph-terminology/\">图结构术语</a> <p>最小生成树是图论中的经典问题，在现实生活中有广泛的应用，比如设计最低成本的通信网络、电路布线、管道铺设等。</p> <p>考虑到最小生成树的算法实现需要一些其他算法作为铺垫，且本文处在基础章节，所以不会详细讲解算法代码。</p> <p>本文主要介绍最小生成树的定义及应用场景，并阐述两种经典的最小生成树算法的核心原理。具体的代码实现安排在数据结构设计章节。</p> <h2 id=\"什么是生成树\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E6%A0%91\"><span>什么是生成树</span></a></h2> <a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E6%A0%91\"><span>什么是生成树</span></a> <span>什么是生成树</span> <p>首先理解什么是生成树。给定一个无向连通图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>，其<strong>生成树</strong>是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 的一个子图，它包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> 中的所有顶点，并且是一棵树（即无环连通图）。</p> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math> <semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics> <mrow><mi>G</mi></mrow> <mi>G</mi> <annotation encoding=\"application/x-tex\">G</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\">G</span> <strong>生成树</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math> <semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics> <mrow><mi>G</mi></mrow> <mi>G</mi> <annotation encoding=\"application/x-tex\">G</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\">G</span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math> <semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics> <mrow><mi>G</mi></mrow> <mi>G</mi> <annotation encoding=\"application/x-tex\">G</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\">G</span> <p>换句话说，生成树具有以下特性：</p> <ul><li>包含原图中的所有顶点。</li><li>边的数量为顶点数减一（<code>V-1</code>条边）。</li><li>连通且无环。</li></ul> <li>包含原图中的所有顶点。</li> <li>边的数量为顶点数减一（<code>V-1</code>条边）。</li> <code>V-1</code> <li>连通且无环。</li> <p>一个图可以有多个不同的生成树，例如这幅加权图：</p> <p>可以有以下生成树，其中属于生成树的边被标记为了红色：</p> <p>下面是一个不同的生成树：</p> <h2 id=\"什么是最小生成树\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span>什么是最小生成树</span></a></h2> <a class=\"header-anchor\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span>什么是最小生成树</span></a> <span>什么是最小生成树</span> <p>如果图是加权图，那么<strong>最小生成树</strong>就是边权重总和最小的生成树。</p> <strong>最小生成树</strong> <p>比如上面展示的例子，第二种生成树是该图的最小生成树，总权重为：2 + 3 + 5 = 10，没有其他的生成树能够得到更小的权重和了。</p> <p>最小生成树在现实生活中有很多应用场景，边的权重可能代表距离、成本、时间等。</p> <p>比方说想在若干城市之间修建公路，图中的节点代表城市，边代表城市之间的公路，边的权重代表修建公路的成本，我们希望找到一种方案能够连接所有城市，且总成本最小，这就是典型的最小生成树问题。</p> <h2 id=\"最小生成树算法\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95\"><span>最小生成树算法</span></a></h2> <a class=\"header-anchor\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95\"><span>最小生成树算法</span></a> <span>最小生成树算法</span> <p>有两种经典的算法用于求解最小生成树问题：Kruskal 算法和 Prim 算法。它们都基于贪心思想，但实现方式不同。</p> <p>Kruskal 算法相对简单一些，只需要先对图中的所有边按照权重排序，然后借助 <a class=\"route-link\" href=\"/algo/data-structure/union-find/\">Union-Find 并查集算法</a> 即可找到最小生成树。</p> <a class=\"route-link\" href=\"/algo/data-structure/union-find/\">Union-Find 并查集算法</a> <p>Prim 算法可以由 <a class=\"route-link\" href=\"/algo/data-structure/dijkstra/\">Dijkstra 算法</a> 拓展而来，借助 <a class=\"route-link\" href=\"/algo/data-structure-basic/binary-heap-basic/\">优先级队列</a> 动态排序的特性，逐步构造最小生成树。</p> <a class=\"route-link\" href=\"/algo/data-structure/dijkstra/\">Dijkstra 算法</a> <a class=\"route-link\" href=\"/algo/data-structure-basic/binary-heap-basic/\">优先级队列</a> <p>具体的代码实现在 <a class=\"route-link\" href=\"/algo/data-structure/kruskal/\">Kruskal 算法</a> 和 <a class=\"route-link\" href=\"/algo/data-structure/prim/\">Prim 算法</a> 中讲解。</p> <a class=\"route-link\" href=\"/algo/data-structure/kruskal/\">Kruskal 算法</a> <a class=\"route-link\" href=\"/algo/data-structure/prim/\">Prim 算法</a> <h2 id=\"随机地图构造问题\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%9B%BE%E6%9E%84%E9%80%A0%E9%97%AE%E9%A2%98\"><span>随机地图构造问题</span></a></h2> <a class=\"header-anchor\" href=\"#%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%9B%BE%E6%9E%84%E9%80%A0%E9%97%AE%E9%A2%98\"><span>随机地图构造问题</span></a> <span>随机地图构造问题</span> <p>最小生成树算法经过一些巧妙的改造后，可以被用于生成游戏中的随机化迷宫、洞穴等场景。</p> <p>其核心思想是利用最小生成树算法<strong>能够连接所有顶点且无环路</strong>的特性，来确保生成地图的连通性。通过引入随机性，可以创造出每次都不同、看起来自然且复杂的地图结构。</p> <strong>能够连接所有顶点且无环路</strong> <p>本站包含一个迷宫小游戏，要求你编写 <code>mazeGenerate</code> 函数生成迷宫地图，要求必须存在至少一条起点到终点的路径，且地图需要尽可能随机：</p> <code>mazeGenerate</code> <p>我们可以借助游戏面板直观体会一下最小生成树算法生成的地图的特点。</p> <p>在游戏面板中可以选择「生成算法」和「求解算法」，你可以切换不同的生成算法，然后点击「生成」按钮，即可查看不同的算法生成地图的过程。</p> <p>先来观察 Krusual 算法，地图被初始化为一个网格图结构，然后从图中的多个位置开始出现随机路径，最终连接成一个完整的迷宫地图。</p> <p>再来观察 Prim 算法，地图的初始状态全部都是障碍物，然后从起点开始向周围扩展路径，最终连接成一个完整的迷宫地图。</p> <p>不只是生成地图的过程不同，生成的地图特点也不同。你可以在游戏面板上切换不同的求解算法，点击「求解」按钮，即可对比查看不同的算法求解地图的过程。</p> <p>我会建议观察 BFS/DFS 算法求解地图的过程，仔细体会一下不同算法生成地图的特点。在后文讲解完最小生成树算法实现之后，我们再具体讲解随机迷宫地图的生成算法。</p> <footer class=\"vp-page-meta\"><!----><div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">最近更新：</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time></div><!----></div></footer> <div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">最近更新：</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time></div><!----></div> <div class=\"update-time\"><span class=\"vp-meta-label\">最近更新：</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time></div> <span class=\"vp-meta-label\">最近更新：</span> <time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>2025/7/21 11:29</time> <nav class=\"vp-page-nav\"><a class=\"route-link auto-link prev\" href=\"/algo/data-structure-basic/graph-shortest-path/\" aria-label=\"图结构最短路径算法概览\"><div class=\"hint\"><span class=\"arrow start\"></span>上一页</div><div class=\"link\"><!---->图结构最短路径算法概览</div></a><a class=\"route-link auto-link next\" href=\"/algo/data-structure-basic/union-find-basic/\" aria-label=\"Union Find 并查集原理\"><div class=\"hint\">下一页<span class=\"arrow end\"></span></div><div class=\"link\">Union Find 并查集原理<!----></div></a></nav> <a class=\"route-link auto-link prev\" href=\"/algo/data-structure-basic/graph-shortest-path/\" aria-label=\"图结构最短路径算法概览\"><div class=\"hint\"><span class=\"arrow start\"></span>上一页</div><div class=\"link\"><!---->图结构最短路径算法概览</div></a> <div class=\"hint\"><span class=\"arrow start\"></span>上一页</div> <span class=\"arrow start\"></span> <div class=\"link\"><!---->图结构最短路径算法概览</div> <a class=\"route-link auto-link next\" href=\"/algo/data-structure-basic/union-find-basic/\" aria-label=\"Union Find 并查集原理\"><div class=\"hint\">下一页<span class=\"arrow end\"></span></div><div class=\"link\">Union Find 并查集原理<!----></div></a> <div class=\"hint\">下一页<span class=\"arrow end\"></span></div> <span class=\"arrow end\"></span> <div class=\"link\">Union Find 并查集原理<!----></div> <div style=\"justify-content:center;display:flex;\" data-v-95bd7423><div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div></div> <div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div> <div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div> <div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div>"
}