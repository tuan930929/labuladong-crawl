{
    "url": "https://labuladong.online/algo/en/data-structure-basic/graph-minimum-spanning-tree/",
    "title": "Minimum Spanning Tree Algorithms Overview | Labuladong Algo Notes",
    "content": "<nav class=\"vp-breadcrumb disable\"></nav> <div class=\"vp-page-title\"><h1><!---->Minimum Spanning Tree Algorithms Overview</h1><div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"AuthorðŸ–Š\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">Original</span><span class=\"page-word-info\" aria-label=\"WordsðŸ” \" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>About 981 words</span><meta property=\"wordCount\" content=\"981\"></span></div><hr></div> <h1><!---->Minimum Spanning Tree Algorithms Overview</h1> <div class=\"page-info\"><span class=\"page-author-info\" aria-label=\"AuthorðŸ–Š\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span><span class=\"page-original-info\">Original</span><span class=\"page-word-info\" aria-label=\"WordsðŸ” \" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>About 981 words</span><meta property=\"wordCount\" content=\"981\"></span></div> <span class=\"page-author-info\" aria-label=\"AuthorðŸ–Š\" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg><span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span><span property=\"author\" content=\"labuladong\"></span></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon author-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"author icon\" name=\"author\"><path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path></svg> <path d=\"M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z\"></path> <span><a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a></span> <a class=\"page-author-item\" href=\"https://github.com/labuladong\" target=\"_blank\" rel=\"noopener noreferrer\">labuladong</a> <span property=\"author\" content=\"labuladong\"></span> <span class=\"page-original-info\">Original</span> <span class=\"page-word-info\" aria-label=\"WordsðŸ” \" data-balloon-pos=\"up\"><svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg><span>About 981 words</span><meta property=\"wordCount\" content=\"981\"></span> <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon word-icon\" viewbox=\"0 0 1024 1024\" fill=\"currentColor\" aria-label=\"word icon\" name=\"word\"><path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path><path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path></svg> <path d=\"M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z\"></path> <path d=\"M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z\"></path> <span>About 981 words</span> <meta property=\"wordCount\" content=\"981\"> <hr> <div class=\"\" vp-content><!----><div id=\"markdown-content\"><div class=\"hint-container info\"><p class=\"hint-container-title\">Prerequisites</p><p>Before reading this article, you need to learn:</p><ul><li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-basic/\">Basics of Graph Structure and Common Code Implementation</a></li><li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-terminology/\">Graph Terminology</a></li></ul></div><p>Minimum Spanning Tree (MST) is a classic problem in graph theory. It has many real-world applications, such as designing the lowest-cost communication networks, circuit wiring, and pipeline layout.</p><p>Since implementing MST algorithms needs some other algorithms as a foundation, and this article is in the basics section, we will not explain the algorithm code in detail here.</p><p>This article mainly introduces the definition and application scenarios of minimum spanning trees, and explains the core ideas of two classic MST algorithms. The detailed code will be provided in the data structure design section.</p><h2 id=\"what-is-a-spanning-tree\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#what-is-a-spanning-tree\"><span>What is a Spanning Tree</span></a></h2><p>First, let's understand what a spanning tree is. Given an undirected connected graph <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, a <strong>spanning tree</strong> is a subgraph of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> that includes all the vertices of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and is a tree (which means it is connected and has no cycles).</p><p>In other words, a spanning tree has these features:</p><ul><li>It includes all the vertices from the original graph.</li><li>The number of edges is one less than the number of vertices (<code>V-1</code> edges).</li><li>It is connected and has no cycles.</li></ul><p>A graph can have many different spanning trees. For example, here is a weighted graph:</p><!----><p>Here are some spanning trees. The edges in the spanning tree are marked in red:</p><!----><p>Here is another spanning tree:</p><!----><h2 id=\"what-is-a-minimum-spanning-tree\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#what-is-a-minimum-spanning-tree\"><span>What is a Minimum Spanning Tree</span></a></h2><p>If the graph is a weighted graph, the <strong>minimum spanning tree</strong> is the spanning tree with the smallest total edge weight.</p><p>For example, in the case above, the second spanning tree is the minimum spanning tree. The total weight is 2 + 3 + 5 = 10. There is no other spanning tree with a smaller total weight.</p><p>Minimum spanning trees have many real-world uses. The edge weights can represent distance, cost, time, and so on.</p><p>For example, if you want to build roads between several cities, the nodes in the graph are cities, the edges are roads, and the weights are the cost to build each road. We want to connect all the cities with the lowest total cost. This is a classic minimum spanning tree problem.</p><h2 id=\"minimum-spanning-tree-algorithms\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#minimum-spanning-tree-algorithms\"><span>Minimum Spanning Tree Algorithms</span></a></h2><p>There are two classic algorithms to solve the minimum spanning tree problem: Kruskal's algorithm and Prim's algorithm. Both use a greedy approach, but their implementation is different.</p><p>Kruskal's algorithm is simpler. First, sort all the edges in the graph by weight, then use the <a class=\"route-link\" href=\"/algo/en/data-structure/union-find/\">Union-Find algorithm</a> to build the minimum spanning tree.</p><p>Prim's algorithm is an extension of the <a class=\"route-link\" href=\"/algo/en/data-structure/dijkstra/\">Dijkstra algorithm</a>. It uses a <a class=\"route-link\" href=\"/algo/en/data-structure-basic/binary-heap-basic/\">priority queue</a> to build the minimum spanning tree step by step.</p><p>You can find the code for these algorithms in <a class=\"route-link\" href=\"/algo/en/data-structure/kruskal/\">Kruskal's Algorithm</a> and <a class=\"route-link\" href=\"/algo/en/data-structure/prim/\">Prim's Algorithm</a>.</p><h2 id=\"random-map-generation-problem\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#random-map-generation-problem\"><span>Random Map Generation Problem</span></a></h2><p>With some clever changes, minimum spanning tree algorithms can be used to generate random mazes and caves for games.</p><p>The main idea is to use the property of minimum spanning trees, which can connect all points without forming cycles. This ensures the map is connected. By adding randomness, we can make each map look different, natural, and complex.</p><p>On this site, there is a maze game. You need to write a function <code>mazeGenerate</code> to create a maze map. The map must have at least one path from start to finish, and should be as random as possible:</p><!----><p>We can use the game panel to see how minimum spanning tree algorithms generate maps.</p><p>In the panel, you can choose a \"generation algorithm\" and a \"solving algorithm\". You can switch between different generation methods, then click the \"Generate\" button to see how each algorithm creates a map.</p><p>First, observe the Kruskal algorithm. The map starts as a grid. Then, random paths begin to appear from different places, finally connecting into a complete maze.</p><p>Next, observe the Prim algorithm. The map starts as all walls. Then, from the starting point, paths spread out, eventually forming a complete maze.</p><p>Not only are the generation processes different, but the maps created have different features. You can also switch between different solving algorithms in the panel. Click the \"Solve\" button to see how each algorithm solves the maze.</p><p>I suggest watching how BFS/DFS algorithms solve the map. Pay attention to the differences in maps made by each generation method. After we explain how minimum spanning tree algorithms work, we will talk more about random maze generation in detail.</p></div><!----><!----><!----></div> <div id=\"markdown-content\"><div class=\"hint-container info\"><p class=\"hint-container-title\">Prerequisites</p><p>Before reading this article, you need to learn:</p><ul><li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-basic/\">Basics of Graph Structure and Common Code Implementation</a></li><li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-terminology/\">Graph Terminology</a></li></ul></div><p>Minimum Spanning Tree (MST) is a classic problem in graph theory. It has many real-world applications, such as designing the lowest-cost communication networks, circuit wiring, and pipeline layout.</p><p>Since implementing MST algorithms needs some other algorithms as a foundation, and this article is in the basics section, we will not explain the algorithm code in detail here.</p><p>This article mainly introduces the definition and application scenarios of minimum spanning trees, and explains the core ideas of two classic MST algorithms. The detailed code will be provided in the data structure design section.</p><h2 id=\"what-is-a-spanning-tree\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#what-is-a-spanning-tree\"><span>What is a Spanning Tree</span></a></h2><p>First, let's understand what a spanning tree is. Given an undirected connected graph <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, a <strong>spanning tree</strong> is a subgraph of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> that includes all the vertices of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and is a tree (which means it is connected and has no cycles).</p><p>In other words, a spanning tree has these features:</p><ul><li>It includes all the vertices from the original graph.</li><li>The number of edges is one less than the number of vertices (<code>V-1</code> edges).</li><li>It is connected and has no cycles.</li></ul><p>A graph can have many different spanning trees. For example, here is a weighted graph:</p><!----><p>Here are some spanning trees. The edges in the spanning tree are marked in red:</p><!----><p>Here is another spanning tree:</p><!----><h2 id=\"what-is-a-minimum-spanning-tree\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#what-is-a-minimum-spanning-tree\"><span>What is a Minimum Spanning Tree</span></a></h2><p>If the graph is a weighted graph, the <strong>minimum spanning tree</strong> is the spanning tree with the smallest total edge weight.</p><p>For example, in the case above, the second spanning tree is the minimum spanning tree. The total weight is 2 + 3 + 5 = 10. There is no other spanning tree with a smaller total weight.</p><p>Minimum spanning trees have many real-world uses. The edge weights can represent distance, cost, time, and so on.</p><p>For example, if you want to build roads between several cities, the nodes in the graph are cities, the edges are roads, and the weights are the cost to build each road. We want to connect all the cities with the lowest total cost. This is a classic minimum spanning tree problem.</p><h2 id=\"minimum-spanning-tree-algorithms\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#minimum-spanning-tree-algorithms\"><span>Minimum Spanning Tree Algorithms</span></a></h2><p>There are two classic algorithms to solve the minimum spanning tree problem: Kruskal's algorithm and Prim's algorithm. Both use a greedy approach, but their implementation is different.</p><p>Kruskal's algorithm is simpler. First, sort all the edges in the graph by weight, then use the <a class=\"route-link\" href=\"/algo/en/data-structure/union-find/\">Union-Find algorithm</a> to build the minimum spanning tree.</p><p>Prim's algorithm is an extension of the <a class=\"route-link\" href=\"/algo/en/data-structure/dijkstra/\">Dijkstra algorithm</a>. It uses a <a class=\"route-link\" href=\"/algo/en/data-structure-basic/binary-heap-basic/\">priority queue</a> to build the minimum spanning tree step by step.</p><p>You can find the code for these algorithms in <a class=\"route-link\" href=\"/algo/en/data-structure/kruskal/\">Kruskal's Algorithm</a> and <a class=\"route-link\" href=\"/algo/en/data-structure/prim/\">Prim's Algorithm</a>.</p><h2 id=\"random-map-generation-problem\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#random-map-generation-problem\"><span>Random Map Generation Problem</span></a></h2><p>With some clever changes, minimum spanning tree algorithms can be used to generate random mazes and caves for games.</p><p>The main idea is to use the property of minimum spanning trees, which can connect all points without forming cycles. This ensures the map is connected. By adding randomness, we can make each map look different, natural, and complex.</p><p>On this site, there is a maze game. You need to write a function <code>mazeGenerate</code> to create a maze map. The map must have at least one path from start to finish, and should be as random as possible:</p><!----><p>We can use the game panel to see how minimum spanning tree algorithms generate maps.</p><p>In the panel, you can choose a \"generation algorithm\" and a \"solving algorithm\". You can switch between different generation methods, then click the \"Generate\" button to see how each algorithm creates a map.</p><p>First, observe the Kruskal algorithm. The map starts as a grid. Then, random paths begin to appear from different places, finally connecting into a complete maze.</p><p>Next, observe the Prim algorithm. The map starts as all walls. Then, from the starting point, paths spread out, eventually forming a complete maze.</p><p>Not only are the generation processes different, but the maps created have different features. You can also switch between different solving algorithms in the panel. Click the \"Solve\" button to see how each algorithm solves the maze.</p><p>I suggest watching how BFS/DFS algorithms solve the map. Pay attention to the differences in maps made by each generation method. After we explain how minimum spanning tree algorithms work, we will talk more about random maze generation in detail.</p></div> <div class=\"hint-container info\"><p class=\"hint-container-title\">Prerequisites</p><p>Before reading this article, you need to learn:</p><ul><li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-basic/\">Basics of Graph Structure and Common Code Implementation</a></li><li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-terminology/\">Graph Terminology</a></li></ul></div> <p class=\"hint-container-title\">Prerequisites</p> <p>Before reading this article, you need to learn:</p> <ul><li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-basic/\">Basics of Graph Structure and Common Code Implementation</a></li><li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-terminology/\">Graph Terminology</a></li></ul> <li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-basic/\">Basics of Graph Structure and Common Code Implementation</a></li> <a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-basic/\">Basics of Graph Structure and Common Code Implementation</a> <li><a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-terminology/\">Graph Terminology</a></li> <a class=\"route-link\" href=\"/algo/en/data-structure-basic/graph-terminology/\">Graph Terminology</a> <p>Minimum Spanning Tree (MST) is a classic problem in graph theory. It has many real-world applications, such as designing the lowest-cost communication networks, circuit wiring, and pipeline layout.</p> <p>Since implementing MST algorithms needs some other algorithms as a foundation, and this article is in the basics section, we will not explain the algorithm code in detail here.</p> <p>This article mainly introduces the definition and application scenarios of minimum spanning trees, and explains the core ideas of two classic MST algorithms. The detailed code will be provided in the data structure design section.</p> <h2 id=\"what-is-a-spanning-tree\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#what-is-a-spanning-tree\"><span>What is a Spanning Tree</span></a></h2> <a class=\"header-anchor\" href=\"#what-is-a-spanning-tree\"><span>What is a Spanning Tree</span></a> <span>What is a Spanning Tree</span> <p>First, let's understand what a spanning tree is. Given an undirected connected graph <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, a <strong>spanning tree</strong> is a subgraph of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> that includes all the vertices of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and is a tree (which means it is connected and has no cycles).</p> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math> <semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics> <mrow><mi>G</mi></mrow> <mi>G</mi> <annotation encoding=\"application/x-tex\">G</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\">G</span> <strong>spanning tree</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math> <semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics> <mrow><mi>G</mi></mrow> <mi>G</mi> <annotation encoding=\"application/x-tex\">G</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\">G</span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> <span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span> <math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math> <semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics> <mrow><mi>G</mi></mrow> <mi>G</mi> <annotation encoding=\"application/x-tex\">G</annotation> <span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span> <span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span> <span class=\"strut\" style=\"height:0.6833em;\"></span> <span class=\"mord mathnormal\">G</span> <p>In other words, a spanning tree has these features:</p> <ul><li>It includes all the vertices from the original graph.</li><li>The number of edges is one less than the number of vertices (<code>V-1</code> edges).</li><li>It is connected and has no cycles.</li></ul> <li>It includes all the vertices from the original graph.</li> <li>The number of edges is one less than the number of vertices (<code>V-1</code> edges).</li> <code>V-1</code> <li>It is connected and has no cycles.</li> <p>A graph can have many different spanning trees. For example, here is a weighted graph:</p> <p>Here are some spanning trees. The edges in the spanning tree are marked in red:</p> <p>Here is another spanning tree:</p> <h2 id=\"what-is-a-minimum-spanning-tree\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#what-is-a-minimum-spanning-tree\"><span>What is a Minimum Spanning Tree</span></a></h2> <a class=\"header-anchor\" href=\"#what-is-a-minimum-spanning-tree\"><span>What is a Minimum Spanning Tree</span></a> <span>What is a Minimum Spanning Tree</span> <p>If the graph is a weighted graph, the <strong>minimum spanning tree</strong> is the spanning tree with the smallest total edge weight.</p> <strong>minimum spanning tree</strong> <p>For example, in the case above, the second spanning tree is the minimum spanning tree. The total weight is 2 + 3 + 5 = 10. There is no other spanning tree with a smaller total weight.</p> <p>Minimum spanning trees have many real-world uses. The edge weights can represent distance, cost, time, and so on.</p> <p>For example, if you want to build roads between several cities, the nodes in the graph are cities, the edges are roads, and the weights are the cost to build each road. We want to connect all the cities with the lowest total cost. This is a classic minimum spanning tree problem.</p> <h2 id=\"minimum-spanning-tree-algorithms\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#minimum-spanning-tree-algorithms\"><span>Minimum Spanning Tree Algorithms</span></a></h2> <a class=\"header-anchor\" href=\"#minimum-spanning-tree-algorithms\"><span>Minimum Spanning Tree Algorithms</span></a> <span>Minimum Spanning Tree Algorithms</span> <p>There are two classic algorithms to solve the minimum spanning tree problem: Kruskal's algorithm and Prim's algorithm. Both use a greedy approach, but their implementation is different.</p> <p>Kruskal's algorithm is simpler. First, sort all the edges in the graph by weight, then use the <a class=\"route-link\" href=\"/algo/en/data-structure/union-find/\">Union-Find algorithm</a> to build the minimum spanning tree.</p> <a class=\"route-link\" href=\"/algo/en/data-structure/union-find/\">Union-Find algorithm</a> <p>Prim's algorithm is an extension of the <a class=\"route-link\" href=\"/algo/en/data-structure/dijkstra/\">Dijkstra algorithm</a>. It uses a <a class=\"route-link\" href=\"/algo/en/data-structure-basic/binary-heap-basic/\">priority queue</a> to build the minimum spanning tree step by step.</p> <a class=\"route-link\" href=\"/algo/en/data-structure/dijkstra/\">Dijkstra algorithm</a> <a class=\"route-link\" href=\"/algo/en/data-structure-basic/binary-heap-basic/\">priority queue</a> <p>You can find the code for these algorithms in <a class=\"route-link\" href=\"/algo/en/data-structure/kruskal/\">Kruskal's Algorithm</a> and <a class=\"route-link\" href=\"/algo/en/data-structure/prim/\">Prim's Algorithm</a>.</p> <a class=\"route-link\" href=\"/algo/en/data-structure/kruskal/\">Kruskal's Algorithm</a> <a class=\"route-link\" href=\"/algo/en/data-structure/prim/\">Prim's Algorithm</a> <h2 id=\"random-map-generation-problem\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#random-map-generation-problem\"><span>Random Map Generation Problem</span></a></h2> <a class=\"header-anchor\" href=\"#random-map-generation-problem\"><span>Random Map Generation Problem</span></a> <span>Random Map Generation Problem</span> <p>With some clever changes, minimum spanning tree algorithms can be used to generate random mazes and caves for games.</p> <p>The main idea is to use the property of minimum spanning trees, which can connect all points without forming cycles. This ensures the map is connected. By adding randomness, we can make each map look different, natural, and complex.</p> <p>On this site, there is a maze game. You need to write a function <code>mazeGenerate</code> to create a maze map. The map must have at least one path from start to finish, and should be as random as possible:</p> <code>mazeGenerate</code> <p>We can use the game panel to see how minimum spanning tree algorithms generate maps.</p> <p>In the panel, you can choose a \"generation algorithm\" and a \"solving algorithm\". You can switch between different generation methods, then click the \"Generate\" button to see how each algorithm creates a map.</p> <p>First, observe the Kruskal algorithm. The map starts as a grid. Then, random paths begin to appear from different places, finally connecting into a complete maze.</p> <p>Next, observe the Prim algorithm. The map starts as all walls. Then, from the starting point, paths spread out, eventually forming a complete maze.</p> <p>Not only are the generation processes different, but the maps created have different features. You can also switch between different solving algorithms in the panel. Click the \"Solve\" button to see how each algorithm solves the maze.</p> <p>I suggest watching how BFS/DFS algorithms solve the map. Pay attention to the differences in maps made by each generation method. After we explain how minimum spanning tree algorithms work, we will talk more about random maze generation in detail.</p> <footer class=\"vp-page-meta\"><!----><div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">Last Updated:</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>7/21/25, 11:29 AM</time></div><!----></div></footer> <div class=\"vp-meta-item git-info\"><div class=\"update-time\"><span class=\"vp-meta-label\">Last Updated:</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>7/21/25, 11:29 AM</time></div><!----></div> <div class=\"update-time\"><span class=\"vp-meta-label\">Last Updated:</span><time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>7/21/25, 11:29 AM</time></div> <span class=\"vp-meta-label\">Last Updated:</span> <time class=\"vp-meta-info\" datetime=\"2025-07-21T03:29:25.280Z\" data-allow-mismatch>7/21/25, 11:29 AM</time> <nav class=\"vp-page-nav\"><a class=\"route-link auto-link prev\" href=\"/algo/en/data-structure-basic/graph-shortest-path/\" aria-label=\"Graph Shortest Path Algorithms Overview\"><div class=\"hint\"><span class=\"arrow start\"></span>Prev</div><div class=\"link\"><!---->Graph Shortest Path Algorithms Overview</div></a><a class=\"route-link auto-link next\" href=\"/algo/en/data-structure-basic/union-find-basic/\" aria-label=\"Basic Concept of Union Find Algorithm\"><div class=\"hint\">Next<span class=\"arrow end\"></span></div><div class=\"link\">Basic Concept of Union Find Algorithm<!----></div></a></nav> <a class=\"route-link auto-link prev\" href=\"/algo/en/data-structure-basic/graph-shortest-path/\" aria-label=\"Graph Shortest Path Algorithms Overview\"><div class=\"hint\"><span class=\"arrow start\"></span>Prev</div><div class=\"link\"><!---->Graph Shortest Path Algorithms Overview</div></a> <div class=\"hint\"><span class=\"arrow start\"></span>Prev</div> <span class=\"arrow start\"></span> <div class=\"link\"><!---->Graph Shortest Path Algorithms Overview</div> <a class=\"route-link auto-link next\" href=\"/algo/en/data-structure-basic/union-find-basic/\" aria-label=\"Basic Concept of Union Find Algorithm\"><div class=\"hint\">Next<span class=\"arrow end\"></span></div><div class=\"link\">Basic Concept of Union Find Algorithm<!----></div></a> <div class=\"hint\">Next<span class=\"arrow end\"></span></div> <span class=\"arrow end\"></span> <div class=\"link\">Basic Concept of Union Find Algorithm<!----></div> <div style=\"justify-content:center;display:flex;\" data-v-95bd7423><div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div></div> <div class=\"artalkCommentsContainer\" data-v-95bd7423><div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div><div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div></div> <div id=\"artalkComments\" style=\"display:none;\" data-v-95bd7423></div> <div style=\"margin-bottom:10px;\" data-v-95bd7423><!----></div>"
}